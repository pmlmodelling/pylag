"""
Data reader for input data generated by ROMS

Note
----
roms_data_reader is implemented in Cython. Only a small portion of the
API is exposed in Python with accompanying documentation. However, more
details can be found in `pylag.data_reader`, where a set of python wrappers
have been implemented.
"""

include "constants.pxi"

cimport cython

import logging

try:
    import configparser
except ImportError:
    import ConfigParser as configparser

import numpy as np

from cpython cimport bool

# Data types used for constructing C data structures
from pylag.data_types_python import DTYPE_INT, DTYPE_FLOAT
from pylag.data_types_cython cimport DTYPE_INT_t, DTYPE_FLOAT_t

from libcpp.string cimport string
from libcpp.vector cimport vector

# PyLag cython imports
from pylag.parameters cimport deg_to_radians
from pylag.particle cimport Particle
from pylag.particle_cpp_wrapper cimport to_string
from pylag.data_reader cimport DataReader
from pylag.unstructured cimport Grid
cimport pylag.interpolation as interp
from pylag.math cimport int_min, float_min

# PyLag python imports
from pylag import variable_library
from pylag.exceptions import PyLagValueError, PyLagRuntimeError
from pylag.numerics import get_time_direction
from pylag.unstructured import get_unstructured_grid


cdef class ROMSDataReader(DataReader):
    """ DataReader for inputs generated by ROMS
    
    Objects of type ROMSDataReader are intended to manage all access to
    data objects defined on ROMS's Arakawa C-grid , including data describing the
    model grid itself as well as model output variables. Provided are methods
    for searching the model grid for host horizontal elements and for
    interpolating gridded field data to a given point in space and time.

    On an Arakawa C-grid, u, v, w and rho points are offset. PyLag's approach to
    dealing with such grids is to create separate unstructured grids for each of
    the three different horizontal grids (for u, v and rho points), with the w
    horizontal grid being the same as the rho grid. With respect to grid boundary
    crossings, the `rho` grid is treated as the edge of the model domain.
    
    Parameters
    ----------
    config : ConfigParser
        Configuration object.
    
    mediator : Mediator
        Mediator object for managing access to data read from file.

    """
    
    # Configurtion object
    cdef object config

    # Mediator for accessing model data read in from file
    cdef object mediator

    # Variable string specifying whether the underlying grid is rectilinear or curvilinear
    cdef object _grid_type

    # List of environmental variables to read and save
    cdef object env_var_names

    # Unstructured grid objects for performing grid searching etc
    cdef Grid _unstructured_grid_u
    cdef Grid _unstructured_grid_v
    cdef Grid _unstructured_grid_rho
    cdef Grid _unstructured_grid_psi

    # The name of the grid
    cdef string _name_grid_u
    cdef string _name_grid_v
    cdef string _name_grid_rho
    cdef string _name_grid_psi

    # Grid dimensions
    cdef DTYPE_INT_t _n_s_rho, _n_s_w
    cdef DTYPE_INT_t _n_longitude_grid_u, _n_latitude_grid_u, _n_elems_grid_u, _n_nodes_grid_u
    cdef DTYPE_INT_t _n_longitude_grid_v, _n_latitude_grid_v, _n_elems_grid_v, _n_nodes_grid_v
    cdef DTYPE_INT_t _n_longitude_grid_rho, _n_latitude_grid_rho, _n_elems_grid_rho, _n_nodes_grid_rho
    cdef DTYPE_INT_t _n_longitude_grid_psi, _n_latitude_grid_psi, _n_elems_grid_psi, _n_nodes_grid_psi
    
    # Element connectivity
    cdef DTYPE_INT_t[:,::1] _nv_grid_u
    cdef DTYPE_INT_t[:,::1] _nv_grid_v
    cdef DTYPE_INT_t[:,::1] _nv_grid_rho
    cdef DTYPE_INT_t[:,::1] _nv_grid_psi
    
    # Element adjacency
    cdef DTYPE_INT_t[:,::1] _nbe_grid_u
    cdef DTYPE_INT_t[:,::1] _nbe_grid_v
    cdef DTYPE_INT_t[:,::1] _nbe_grid_rho
    cdef DTYPE_INT_t[:,::1] _nbe_grid_psi

    # Grid angles
    cdef DTYPE_FLOAT_t[::1] _rho_angles

    # Minimum nodal x/y values
    cdef DTYPE_FLOAT_t _xmin
    cdef DTYPE_FLOAT_t _ymin

    # Vertical transform function
    cdef DTYPE_INT_t _vtransform

    # Boolean flag signifying whether the vertical grid should be flipped
    cdef bint _flip_vertical_axis

    # Depth coordinate variables (xarray DataArrays)
    cdef DTYPE_FLOAT_t[::1] _s_rho
    cdef DTYPE_FLOAT_t[::1] _cs_r
    cdef DTYPE_FLOAT_t[::1] _s_w
    cdef DTYPE_FLOAT_t[::1] _cs_w
    cdef DTYPE_FLOAT_t _hc

    # Actual depth levels, accounting for changes in sea surface elevation on rho and w grids
    cdef DTYPE_FLOAT_t[:, ::1] _depth_levels_grid_rho_last
    cdef DTYPE_FLOAT_t[:, ::1] _depth_levels_grid_rho_next
    cdef DTYPE_FLOAT_t[:, ::1] _depth_levels_grid_w_last
    cdef DTYPE_FLOAT_t[:, ::1] _depth_levels_grid_w_next

    # Bathymetry
    cdef DTYPE_FLOAT_t[::1] _h

    # Land sea mask on nodes (1 - sea point, 0 - land point)
    #cdef DTYPE_INT_t[:] _mask_grid_u, _mask_grid_v, _mask_grid_rho

    # Land sea mask on rho grid elements (1 - sea point, 0 - land point)
    cdef DTYPE_INT_t[::1] _mask_c_grid_u
    cdef DTYPE_INT_t[::1] _mask_c_grid_v
    cdef DTYPE_INT_t[::1] _mask_c_grid_rho
    cdef DTYPE_INT_t[::1] _mask_c_grid_psi

    # Land sea mask on rho grid nodes (1 - sea point, 0 - land point)
    cdef DTYPE_INT_t[::1] _mask_grid_u
    cdef DTYPE_INT_t[::1] _mask_grid_v
    cdef DTYPE_INT_t[::1] _mask_grid_rho
    cdef DTYPE_INT_t[::1] _mask_grid_psi

    # Dictionary of dimension names
    cdef object _dimension_names

    # Dictionary of variable names
    cdef object _variable_names

    # Dictionary containing tuples of variable shapes without time (e.g. {'u': (n_dpeth, n_latitude, n_longitude)})
    cdef object _variable_shapes

    # Dictionaries of variable dimension indices (e.g. {'u': {'depth': 0, 'latitude': 1, 'longitude': 2}})
    cdef object _variable_dimension_indices

    # Sea surface elevation
    cdef DTYPE_FLOAT_t[::1] _zeta_last
    cdef DTYPE_FLOAT_t[::1] _zeta_next
    
    # u/v/w velocity components
    cdef DTYPE_FLOAT_t[:,::1] _u_last
    cdef DTYPE_FLOAT_t[:,::1] _u_next
    cdef DTYPE_FLOAT_t[:,::1] _v_last
    cdef DTYPE_FLOAT_t[:,::1] _v_next
    cdef DTYPE_FLOAT_t[:,::1] _w_last
    cdef DTYPE_FLOAT_t[:,::1] _w_next
    
    # Vertical eddy diffusivities
    cdef DTYPE_FLOAT_t[:,::1] _Kz_last
    cdef DTYPE_FLOAT_t[:,::1] _Kz_next

    # Horizontal eddy viscosities
    cdef DTYPE_FLOAT_t[:,::1] _ah_last
    cdef DTYPE_FLOAT_t[:,::1] _ah_next

    # Wet/dry status of elements
    cdef DTYPE_INT_t[::1] _wet_cells_last
    cdef DTYPE_INT_t[::1] _wet_cells_next

    # Sea water potential temperature
    cdef DTYPE_FLOAT_t[:,::1] _thetao_last
    cdef DTYPE_FLOAT_t[:,::1] _thetao_next

    # Sea water salinity
    cdef DTYPE_FLOAT_t[:,::1] _so_last
    cdef DTYPE_FLOAT_t[:,::1] _so_next

    # Time direction
    cdef DTYPE_INT_t _time_direction

    # Time array
    cdef DTYPE_FLOAT_t _time_last
    cdef DTYPE_FLOAT_t _time_next

    # Options controlling the reading of eddy diffusivities
    cdef object _Kz_method_name, _Ah_method_name
    cdef DTYPE_INT_t _Kz_method, _Ah_method

    # Flags that identify whether a given variable should be read in
    cdef bint _has_w, _has_is_wet,  _has_zeta

    def __init__(self, config, mediator):
        self.config = config
        self.mediator = mediator

        self._name_grid_u = b'grid_u'
        self._name_grid_v = b'grid_v'
        self._name_grid_rho = b'grid_rho'
        self._name_grid_psi = b'grid_psi'

        # Time direction
        self._time_direction = <int>get_time_direction(config)

        # Grid type - rectilinear or curvilinear
        self._grid_type = self.config.get("OCEAN_DATA", "grid_type").strip().lower()
        if self._grid_type not in ['rectilinear', 'curvilinear']:
            raise RuntimeError('Invalid grid type {}. Valid choices are `rectilinear` or `curvilinear`.'.format(self._grid_type))

        # Setup dimension name mappings
        self._dimension_names = {}
        dim_config_names = {'time': 'time_dim_name',
                            'depth_grid_rho': 'depth_dim_name_grid_rho',
                            'depth_grid_w': 'depth_dim_name_grid_w',
                            'latitude_grid_u': 'latitude_dim_name_grid_u',
                            'longitude_grid_u': 'longitude_dim_name_grid_u',
                            'latitude_grid_v': 'latitude_dim_name_grid_v',
                            'longitude_grid_v': 'longitude_dim_name_grid_v',
                            'latitude_grid_rho': 'latitude_dim_name_grid_rho',
                            'longitude_grid_rho': 'longitude_dim_name_grid_rho',
                            'latitude_grid_psi': 'latitude_dim_name_grid_psi',
                            'longitude_grid_psi': 'longitude_dim_name_grid_psi'}

        for dim_name, config_name in dim_config_names.items():
            self._dimension_names[dim_name] = self.config.get('OCEAN_DATA', config_name).strip()

        # Setup variable name mappings
        self._variable_names = {}
        var_config_names = {'uo': 'uo_var_name', 'vo': 'vo_var_name', 'wo': 'wo_var_name', 'zos': 'zos_var_name',
                            'Kz': 'Kz_var_name', 'Ah': 'Ah_var_name', 'thetao': 'thetao_var_name',
                            'so': 'so_var_name', 'wetdry_mask_rho': 'wetdry_var_name'}
        for var_name, config_name in var_config_names.items():
            try:
                var = self.config.get('OCEAN_DATA', config_name).strip()
                if var:
                    self._variable_names[var_name] = var
            except (configparser.NoOptionError) as e:
                pass

        # Initialise dictionaries for variable shapes and dimension indices
        self._variable_shapes = {}
        self._variable_dimension_indices = {}

        # Set boolean flags
        self._has_zeta = True if 'zos' in self._variable_names else False
        self._has_w = True if 'wo' in self._variable_names else False

        # Set options for handling the vertical eddy diffusivity
        self._Kz_method_name = self.config.get('OCEAN_DATA', 'Kz_method').strip().lower()
        if self._Kz_method_name not in ['none', 'file']:
            raise RuntimeError('Invalid option for `Kz_method` ({})'.format(self._Kz_method_name))

        if self._Kz_method_name == "none":
            self._Kz_method = 0
        elif self._Kz_method_name == "file":
            # Make sure a value for `Kz_var_name` has been provided.
            if 'Kz' not in self._variable_names:
                raise RuntimeError('The configuration file states that Kz data should be read from file \n'
                                    'yet a name for the Kz variable (`Kz_var_name`) has not been given \n'
                                    'or the config option was not included.')
            self._Kz_method = 1


        # Set options for handling the horizontal eddy diffusivity
        self._Ah_method_name = self.config.get('OCEAN_DATA', 'Ah_method').strip().lower()
        if self._Ah_method_name not in ['none', 'file']:
            raise RuntimeError('Invalid option for `Ah_method` ({})'.format(self._Ah_method_name))

        if self._Ah_method_name == "none":
            self._Ah_method = 0
        elif self._Ah_method_name == "file":
            # Make sure a value for `Ah_var_name` has been provided.
            if 'Ah' not in self._variable_names:
                raise RuntimeError('The configuration file states that Ah data should be read from file \n'
                                    'yet a name for the Ah variable (`Ah_var_name`) has not been given \n'
                                    'or the config option was not included.')
            self._Ah_method = 1

        # Has is wet flag?
        self._has_is_wet = self.config.getboolean("OCEAN_DATA", "has_is_wet")

        # Check to see if any environmental variables are being saved.
        try:
            env_var_names = self.config.get("OUTPUT", "environmental_variables").strip().split(',')
        except (configparser.NoSectionError, configparser.NoOptionError) as e:
            env_var_names = []

        self.env_var_names = []
        for env_var_name in env_var_names:
            env_var_name = env_var_name.strip()
            if env_var_name is not None:
                if env_var_name not in self._variable_names.keys():
                    raise ValueError("Received request to track environmental tracer `{}'. However, "\
                            "the corresponding NetCDF variable name was not given. If the variable has been "\
                            "saved within the inputs, please specify its name in the run config.".format(env_var_name))

                if env_var_name not in variable_library.standard_variable_names.keys():
                    raise ValueError("Support for tracking the environmental tracer `{}' does not currently "\
                            "exist within PyLag".format(env_var_name))

                self.env_var_names.append(env_var_name)

        self._read_grid()

        self._read_time_dependent_vars()

    cpdef get_grid_names(self):
        """ Return a list of grid names

        Returns
        -------
         : list [str]
             List of grid names on which which input data are defined.
        """
        return [self._name_grid_u.decode(), self._name_grid_v.decode(),
                self._name_grid_rho.decode(), self._name_grid_psi.decode()]

    cpdef setup_data_access(self, start_datetime, end_datetime):
        """ Set up access to time-dependent variables.
        
        Parameters
        ----------
        start_datetime : Datetime
            Datetime object corresponding to the simulation start time.
        
        end_datetime : Datetime
            Datetime object corresponding to the simulation end time.
        """
        self.mediator.setup_data_access(start_datetime, end_datetime)

        self._read_time_dependent_vars()

    cpdef read_data(self, DTYPE_FLOAT_t time):
        """ Read in time dependent variable data from file?
        
        `time` is used to test if new data should be read in from file. If this
        is the case, arrays containing time-dependent variable data are updated.
        
        Parameters
        ----------
        time : float
            The current time.
        """
        cdef DTYPE_FLOAT_t time_fraction

        time_fraction = interp.get_linear_fraction(time, self._time_last, self._time_next)
        if self._time_direction == 1:
            if time_fraction < 0.0 or time_fraction >= 1.0:
                self.mediator.update_reading_frames(time)
                self._read_time_dependent_vars()
        else:
            if time_fraction <= 0.0 or time_fraction > 1.0:
                self.mediator.update_reading_frames(time)
                self._read_time_dependent_vars()

    cdef DTYPE_INT_t find_host(self, Particle *particle_old,
                               Particle *particle_new) except INT_ERR:
        """ Returns the host horizontal element.
        
        This function first tries to find the new host horizontal elements using
        a local search algorithm based on the new point's barycentric
        coordinates within the four grids. This is relatively fast. However,
        it can incorrectly flag that a particle has left the domain when in-fact
        it hasn't. For this reason, when the local host element search indicates
        that a particle has left the domain, a check is performed based on the particle's
        pathline - if this crosses a known boundary, the particle is deemed
        to have left the domain.

        The function returns a flag that indicates whether or not the particle
        has been found within the domain. If it has, it's host element will 
        have been set appropriately. If not, the the new particle's host
        element will have been set to the last host elements the particle passed
        through before exiting the domain.

        Land and open boundary crossings are tested for and flagged on the psi grid,
        which defines the corners of grid cells. Once the particle has been located on
        the psi grid, a search is performed on the remaining grid. If the search is
        successful on the psi grid but fails on one of the other grids a runtime
        error is raised.

        Conventions
        -----------
        flag = IN_DOMAIN:
            This indicates that the particle was found successfully. The host element
            of the new particle on all three grids has been set.
        
        flag = LAND_BDY_CROSSED:
            This indicates that the particle exited the domain across a land
            boundary. Host elements are set to the last element the particle passed
            through before exiting the domain.

        flag = OPEN_BDY_CROSSED:
            This indicates that the particle exited the domain across an open
            boundary. Host elements are set to the last element the particle passed
            through before exiting the domain.

        flag = IN_MASKED_ELEM:
            This indicated the particle is in the domain but the element it is
            in is masked. The flag is only returned by the local and global
            search algorithms.

        Parameters
        ----------
        particle_old: *Particle
            The particle at its old position.

        particle_new: *Particle
            The particle at its new position. The host elements will be updated.
        
        Returns
        -------
        flag : int
            Integer flag that indicates whether or not the search was successful.
        """
        cdef DTYPE_INT_t flag, host_grid_u, host_grid_v, host_grid_rho, host_grid_psi

        # Grid psi
        # --------
        host_grid_psi = particle_new.get_host_horizontal_elem(self._name_grid_psi)
        particle_new.set_host_horizontal_elem(self._name_grid_psi,
                                              particle_old.get_host_horizontal_elem(self._name_grid_psi))
        flag = self._unstructured_grid_psi.find_host_using_local_search(particle_new)

        if flag != IN_DOMAIN:
            particle_new.set_host_horizontal_elem(self._name_grid_psi, host_grid_psi)
            flag = self._unstructured_grid_psi.find_host_using_particle_tracing(particle_old,
                                                                                particle_new)

        if flag != IN_DOMAIN:
            return flag

        # Grid U
        # ------
        host_grid_u = particle_new.get_host_horizontal_elem(self._name_grid_u)
        particle_new.set_host_horizontal_elem(self._name_grid_u,
                                              particle_old.get_host_horizontal_elem(self._name_grid_u))
        flag = self._unstructured_grid_u.find_host_using_local_search(particle_new)

        if flag != IN_DOMAIN:
            particle_new.set_host_horizontal_elem(self._name_grid_u, host_grid_u)
            flag = self._unstructured_grid_u.find_host_using_particle_tracing(particle_old,
                                                                              particle_new)
        # Check for open boundary crossing
        if flag != IN_DOMAIN:
            raise RuntimeError('Unable to locate particle on ROMS U grid')

        # Grid V
        # ------
        host_grid_v = particle_new.get_host_horizontal_elem(self._name_grid_v)
        particle_new.set_host_horizontal_elem(self._name_grid_v,
                                              particle_old.get_host_horizontal_elem(self._name_grid_v))
        flag = self._unstructured_grid_v.find_host_using_local_search(particle_new)

        # Double check to see if the particle has left the V-grid
        if flag != IN_DOMAIN:
            particle_new.set_host_horizontal_elem(self._name_grid_v, host_grid_v)
            flag = self._unstructured_grid_v.find_host_using_particle_tracing(particle_old,
                                                                              particle_new)

        # Check for open boundary crossing
        if flag != IN_DOMAIN:
            raise RuntimeError('Unable to locate particle on ROMS V grid')

        # Grid rho
        # --------
        host_grid_rho = particle_new.get_host_horizontal_elem(self._name_grid_rho)
        particle_new.set_host_horizontal_elem(self._name_grid_rho,
                                              particle_old.get_host_horizontal_elem(self._name_grid_rho))
        flag = self._unstructured_grid_rho.find_host_using_local_search(particle_new)

        if flag != IN_DOMAIN:
            particle_new.set_host_horizontal_elem(self._name_grid_rho, host_grid_rho)
            flag = self._unstructured_grid_rho.find_host_using_particle_tracing(particle_old,
                                                                                particle_new)

        if flag != IN_DOMAIN:
            raise RuntimeError('Unable to locate particle on ROMS rho grid')

        return flag

    cdef DTYPE_INT_t find_host_using_local_search(self, Particle *particle) except INT_ERR:
        """ Set host horizontal elements through local searching
        
        Parameters
        ----------
        particle: *Particle
            The particle.

        Returns
        -------
        flag : int
            Integer flag that indicates whether or not the search was successful.
        """
        cdef DTYPE_INT_t flag

        flag = self._unstructured_grid_psi.find_host_using_local_search(particle)
        if flag != IN_DOMAIN:
            return flag

        flag = self._unstructured_grid_u.find_host_using_local_search(particle)
        if flag != IN_DOMAIN:
            raise RuntimeError('Failed to find particle on ROMS U grid.')

        flag = self._unstructured_grid_v.find_host_using_local_search(particle)
        if flag != IN_DOMAIN:
            raise RuntimeError('Failed to find particle on ROMS V grid.')

        flag = self._unstructured_grid_rho.find_host_using_local_search(particle)
        if flag != IN_DOMAIN:
            raise RuntimeError('Failed to find particle on ROMS rho grid.')

        return flag

    cdef DTYPE_INT_t find_host_using_global_search(self, Particle *particle) except INT_ERR:
        """ Set host horizontal elements through global searching
        
        Parameters
        ----------
        particle_old: *Particle
            The particle.
        
        Returns
        -------
        flag : int
            Integer flag that indicates whether or not the search was successful.
        """
        cdef DTYPE_INT_t flag

        flag = self._unstructured_grid_psi.find_host_using_global_search(particle)
        if flag != IN_DOMAIN:
            return flag

        flag = self._unstructured_grid_u.find_host_using_global_search(particle)
        if flag != IN_DOMAIN:
            raise RuntimeError('Failed to find particle on ROMS U grid.')

        flag = self._unstructured_grid_v.find_host_using_global_search(particle)
        if flag != IN_DOMAIN:
            raise RuntimeError('Failed to find particle on ROMS V grid.')

        flag = self._unstructured_grid_rho.find_host_using_global_search(particle)
        if flag != IN_DOMAIN:
            raise RuntimeError('Failed to find particle on ROMS rho grid.')

        return flag

    cdef get_boundary_intersection(self,
                                   Particle *particle_old,
                                   Particle *particle_new,
                                   DTYPE_FLOAT_t start_point[2],
                                   DTYPE_FLOAT_t end_point[2],
                                   DTYPE_FLOAT_t intersection[2]):
        """ Find the boundary intersection point

        This function is a wrapper for the same function implemented in UnstructuredGrid.

        Parameters
        ----------
        particle_old: *Particle
            The particle at its old position.

        particle_new: *Particle
            The particle at its new position.

        start_point : C array, float
            Start coordinates of the side the particle crossed.

        end_point : C array, float
            End coordinates of the side the particle crossed.

        intersection : C array, float
            Coordinates of the intersection point.

        Returns
        -------
        """
        return self._unstructured_grid_psi.get_boundary_intersection(particle_old, particle_new, start_point,
                                                                     end_point, intersection)

    cdef set_default_location(self, Particle *particle):
        """ Set default location

        Move the particle to the centroid of the psi grid element it last passed through
        """
        cdef DTYPE_INT_t flag

        self._unstructured_grid_psi.set_default_location(particle)

        # Use global searching to find the rho, u and v grid hosts and local coordinates
        flag = self._unstructured_grid_rho.find_host_using_local_search(particle)

        if flag == IN_DOMAIN:
            flag = self._unstructured_grid_u.find_host_using_local_search(particle)

        if flag == IN_DOMAIN:
            flag = self._unstructured_grid_v.find_host_using_local_search(particle)

        if flag != IN_DOMAIN:
            raise RuntimeError('Failed to set rho, u and or v grid hosts/local coordinates')

        return

    cdef set_local_coordinates(self, Particle *particle):
        """ Set local coordinates

        Parameters
        ----------
        particle: *Particle
            Pointer to a Particle struct
        """
        self._unstructured_grid_u.set_local_coordinates(particle)
        self._unstructured_grid_v.set_local_coordinates(particle)
        self._unstructured_grid_rho.set_local_coordinates(particle)
        self._unstructured_grid_psi.set_local_coordinates(particle)

        return

    cdef DTYPE_INT_t set_vertical_grid_vars(self, DTYPE_FLOAT_t time,
                                            Particle *particle) except INT_ERR:
        """ Find the host depth layer
        
        """

        cdef DTYPE_FLOAT_t time_fraction = interp.get_linear_fraction_safe(time, self._time_last, self._time_next)

        cdef DTYPE_INT_t host_element = particle.get_host_horizontal_elem(self._name_grid_rho)

        cdef DTYPE_FLOAT_t x3 = particle.get_x3()

        cdef DTYPE_FLOAT_t depth_upper_level_grid_w, depth_lower_level_grid_w

        cdef DTYPE_FLOAT_t depth_upper_level_grid_rho, depth_lower_level_grid_rho

        cdef DTYPE_INT_t k

        # Loop over all depth levels to find the host z layer
        depth_lower_level_grid_w = self._unstructured_grid_rho.interpolate_in_time_and_space(self._depth_levels_grid_w_last,
                                                                                             self._depth_levels_grid_w_next,
                                                                                             0,
                                                                                             time_fraction,
                                                                                             particle)
        for k in xrange(self._n_s_w - 1):
            depth_upper_level_grid_w = depth_lower_level_grid_w
            depth_lower_level_grid_w = self._unstructured_grid_rho.interpolate_in_time_and_space(self._depth_levels_grid_w_last,
                                                                                                 self._depth_levels_grid_w_next,
                                                                                                 k+1,
                                                                                                 time_fraction,
                                                                                                 particle)

            if x3 <= depth_upper_level_grid_w and x3 >= depth_lower_level_grid_w:
                # Host layer found
                particle.set_k_layer(k)

                # Set the depth level interpolation coefficient
                particle.set_omega_interfaces(interp.get_linear_fraction(x3, depth_lower_level_grid_w,
                                              depth_upper_level_grid_w))

                # Set variables describing where on the rho grid the particle
                # sits and whether or not it resides in a boundary layer
                depth_test = self._unstructured_grid_rho.interpolate_in_time_and_space(self._depth_levels_grid_rho_last,
                                                                                       self._depth_levels_grid_rho_next,
                                                                                       k,
                                                                                       time_fraction,
                                                                                       particle)

                # Is x3 in the top or bottom boundary layer?
                if (k == 0 and x3 >= depth_test):
                    particle.set_in_surface_boundary_layer(True)
                    particle.set_in_bottom_boundary_layer(False)
                    return IN_DOMAIN
                elif (k == self._n_s_rho - 1 and x3 <= depth_test):
                    particle.set_in_surface_boundary_layer(False)
                    particle.set_in_bottom_boundary_layer(True)
                    return IN_DOMAIN

                # x3 bounded by upper and lower sigma layers
                particle.set_in_surface_boundary_layer(False)
                particle.set_in_bottom_boundary_layer(False)
                if x3 >= depth_test:
                    particle.set_k_upper_layer(k - 1)
                    particle.set_k_lower_layer(k)
                else:
                    particle.set_k_upper_layer(k)
                    particle.set_k_lower_layer(k + 1)

                # Set the rho vert grid interpolation coefficient
                depth_lower_level_grid_rho = self._unstructured_grid_rho.interpolate_in_time_and_space(self._depth_levels_grid_rho_last,
                                                                                                       self._depth_levels_grid_rho_next,
                                                                                                       particle.get_k_lower_layer(),
                                                                                                       time_fraction,
                                                                                                       particle)

                depth_upper_level_grid_rho = self._unstructured_grid_rho.interpolate_in_time_and_space(self._depth_levels_grid_rho_last,
                                                                                                       self._depth_levels_grid_rho_next,
                                                                                                       particle.get_k_upper_layer(),
                                                                                                       time_fraction,
                                                                                                       particle)

                particle.set_omega_layers(interp.get_linear_fraction(x3, depth_lower_level_grid_rho, depth_upper_level_grid_rho))

                return IN_DOMAIN

        return BDY_ERROR

    cpdef DTYPE_FLOAT_t get_xmin(self) except FLOAT_ERR:
        """ Get minimum x-value for the domain

        Returns
        -------
         : float
             The minimum value of `x` across the grid.
        """
        return self._xmin

    cpdef DTYPE_FLOAT_t get_ymin(self) except FLOAT_ERR:
        """ Get minimum y-value for the domain

        Returns
        -------
         : float
             The minimum value of `y` across the grid.
        """
        return self._ymin

    cdef DTYPE_FLOAT_t get_zmin(self, DTYPE_FLOAT_t time, Particle *particle) except FLOAT_ERR:
        """ Returns the bottom depth in cartesian coordinates

        h is defined at element nodes. Linear interpolation in space is used
        to compute h(x,y). NB the negative of h (which is +ve downwards) is
        returned.

        Parameters
        ----------
        time : float
            Time.

        particle: *Particle
            Pointer to a Particle object.

        Returns
        -------
        zmin : float
            The bottom depth.
        """
        cdef DTYPE_FLOAT_t time_fraction # Time interpolation coefficient

        cdef DTYPE_FLOAT_t h # Bathymetry at (x1, x2)

        time_fraction = interp.get_linear_fraction_safe(time, self._time_last, self._time_next)

        h = self._unstructured_grid_rho.interpolate_in_time_and_space(self._depth_levels_grid_w_last,
                                                                      self._depth_levels_grid_w_next,
                                                                      self._n_s_w - 1,
                                                                      time_fraction,
                                                                      particle)

        return h

    cdef DTYPE_FLOAT_t get_zmax(self, DTYPE_FLOAT_t time, Particle *particle) except FLOAT_ERR:
        """ Returns the sea surface height in cartesian coordinates

        zeta is defined at element nodes. Interpolation proceeds through linear
        interpolation in time followed by interpolation in space.

        Parameters
        ----------
        time : float
            Time.

        particle: *Particle
            Pointer to a Particle object.
        
        Returns
        -------
        zmax : float
            Sea surface elevation.
        """
        cdef DTYPE_FLOAT_t time_fraction # Time interpolation coefficient

        cdef DTYPE_FLOAT_t zeta # Sea surface elevation at (t, x1, x2)

        time_fraction = interp.get_linear_fraction_safe(time, self._time_last, self._time_next)

        zeta = self._unstructured_grid_rho.interpolate_in_time_and_space(self._depth_levels_grid_w_last,
                                                                         self._depth_levels_grid_w_next,
                                                                         0,
                                                                         time_fraction,
                                                                         particle)

        return zeta

    cdef void get_velocity(self, DTYPE_FLOAT_t time, Particle* particle,
            DTYPE_FLOAT_t vel[3]) except +:
        """ Returns the velocity u(t,x,y,z) through interpolation
        
        Returns the velocity u(t,x,y,z) through interpolation.

        Parameters
        ----------
        time : float
            Time at which to interpolate.
        
        particle: *Particle
            Pointer to a Particle object.

        Return
        ------
        vel : C array, float
            u/v/w velocity components stored in a C array.           
        """
        # Time interpolation coefficient
        cdef DTYPE_FLOAT_t time_fraction

        # Particle k_layer
        cdef DTYPE_INT_t k_layer, k_lower_layer, k_upper_layer

        # Velocity components
        cdef DTYPE_FLOAT_t up1, up2, vp1, vp2, wp1, wp2

        # Interpolated values on lower and upper bounding depth levels
        cdef DTYPE_FLOAT_t var_level_1
        cdef DTYPE_FLOAT_t var_level_2

        k_layer = particle.get_k_layer()
        k_lower_layer = particle.get_k_lower_layer()
        k_upper_layer = particle.get_k_upper_layer()

        time_fraction = interp.get_linear_fraction_safe(time, self._time_last, self._time_next)

        # u and v components
        if (particle.get_in_surface_boundary_layer() is True or particle.get_in_bottom_boundary_layer() is True):
            up1 = self._unstructured_grid_u.interpolate_in_time_and_space(self._u_last,
                                                                          self._u_next,
                                                                          k_layer,
                                                                          time_fraction, particle)
            vp1 = self._unstructured_grid_v.interpolate_in_time_and_space(self._v_last,
                                                                          self._v_next,
                                                                          k_layer,
                                                                          time_fraction, particle)

            # Code here desgined to facilitate modifying the velocity field near to the boundary.
            # Without modification, we are effectively extrapolating the velocity field to the 
            # boundary. 
            if particle.get_in_surface_boundary_layer() is True:
                vel[0] = up1
                vel[1] = vp1
            elif particle.get_in_bottom_boundary_layer() is True:
                vel[0] = up1
                vel[1] = up2
        else:
            # u-component
            up1 = self._unstructured_grid_u.interpolate_in_time_and_space(self._u_last,
                                                                          self._u_next,
                                                                          k_lower_layer,
                                                                          time_fraction, particle)
            up2 = self._unstructured_grid_u.interpolate_in_time_and_space(self._u_last,
                                                                          self._u_next,
                                                                          k_upper_layer,
                                                                          time_fraction, particle)

            vel[0] = interp.linear_interp(particle.get_omega_layers(), up1, up2)

            # v-component
            vp1 = self._unstructured_grid_v.interpolate_in_time_and_space(self._v_last,
                                                                          self._v_next,
                                                                          k_lower_layer,
                                                                          time_fraction, particle)
            vp2 = self._unstructured_grid_v.interpolate_in_time_and_space(self._v_last,
                                                                          self._v_next,
                                                                          k_upper_layer,
                                                                          time_fraction, particle)

            vel[1] = interp.linear_interp(particle.get_omega_layers(), vp1, vp2)

        # w-component
        if self._has_w:
            wp1 = self._unstructured_grid_rho.interpolate_in_time_and_space(self._w_last,
                                                                            self._w_next,
                                                                            k_layer+1,
                                                                            time_fraction, particle)
            wp2 = self._unstructured_grid_rho.interpolate_in_time_and_space(self._w_last,
                                                                            self._w_next,
                                                                            k_layer,
                                                                            time_fraction, particle)

            # If logic added to facilitate modifying the velocity field near to the boundary
            if particle.get_in_surface_boundary_layer() is True:
                vel[2] = interp.linear_interp(particle.get_omega_interfaces(), wp1, wp2)
            elif particle.get_in_bottom_boundary_layer() is True:
                vel[2] = interp.linear_interp(particle.get_omega_interfaces(), wp1, wp2)
            else:
                vel[2] = interp.linear_interp(particle.get_omega_layers(), wp1, wp2)
        else:
            vel[2] = 0.0

        return

    cdef DTYPE_FLOAT_t get_environmental_variable(self, var_name,
            DTYPE_FLOAT_t time, Particle *particle) except FLOAT_ERR:
        """ Returns the value of the given environmental variable through interpolation

        Support for extracting the following environmental variables has been implemented:

        thetao - Sea water potential temperature

        so - Sea water salinty

        Parameters
        ----------
        var_name : str
            The name of the variable. See above for a list of supported options.

        time : float
            Time at which to interpolate.

        particle: *Particle
            Pointer to a Particle object.

        Returns:
        --------
        var : float
            The interpolated value of the variable at the specified point in time and space.
        """
        # Variables used in interpolation in time
        cdef DTYPE_FLOAT_t time_fraction

        # Particle k layers
        cdef DTYPE_INT_t k_layer = particle.get_k_layer()
        cdef DTYPE_INT_t k_lower_layer = particle.get_k_lower_layer()
        cdef DTYPE_INT_t k_upper_layer = particle.get_k_upper_layer()

        # Interpolated values on lower and upper bounding sigma layers
        cdef DTYPE_FLOAT_t var_lower_layer
        cdef DTYPE_FLOAT_t var_upper_layer

        # Time fraction
        time_fraction = interp.get_linear_fraction_safe(time, self._time_last, self._time_next)

        if var_name in self.env_var_names:
            if var_name == 'thetao':
                if (particle.get_in_surface_boundary_layer() is True or particle.get_in_bottom_boundary_layer() is True):
                    return self._unstructured_grid_rho.interpolate_in_time_and_space(self._thetao_last,
                                                                                     self._thetao_next,
                                                                                     k_layer,
                                                                                     time_fraction, particle)
                else:
                    var_lower_layer = self._unstructured_grid_rho.interpolate_in_time_and_space(self._theato_last,
                                                                                                self._thetao_next,
                                                                                                k_lower_layer,
                                                                                                time_fraction, particle)

                    var_upper_layer = self._unstructured_grid_rho.interpolate_in_time_and_space(self._theato_last,
                                                                                                self._thetao_next,
                                                                                                k_upper_layer,
                                                                                                time_fraction, particle)
            elif var_name == 'so':
                if (particle.get_in_surface_boundary_layer() is True or particle.get_in_bottom_boundary_layer() is True):
                    return self._unstructured_grid_rho.interpolate_in_time_and_space(self._so_last,
                                                                                     self._so_next,
                                                                                     k_layer,
                                                                                     time_fraction, particle)
                else:
                    var_lower_layer = self._unstructured_grid_rho.interpolate_in_time_and_space(self._so_last,
                                                                                                self._so_next,
                                                                                                k_lower_layer,
                                                                                                time_fraction, particle)

                    var_upper_layer = self._unstructured_grid_rho.interpolate_in_time_and_space(self._so_last,
                                                                                                self._so_next,
                                                                                                k_upper_layer,
                                                                                                time_fraction, particle)

            return interp.linear_interp(particle.get_omega_layers(), var_lower_layer, var_upper_layer)
        else:
            raise ValueError("Invalid variable name `{}'".format(var_name))

    cdef DTYPE_FLOAT_t get_horizontal_eddy_diffusivity(self, DTYPE_FLOAT_t time,
            Particle* particle) except FLOAT_ERR:
        """ Returns the horizontal eddy diffusivity through interpolation

        Parameters
        ----------
        time : float
            Time at which to interpolate.

        particle: *Particle
            Pointer to a Particle object.

        Returns
        -------
        viscofh : float
            The interpolated value of the horizontal eddy diffusivity at the specified point in time and space.
        """
               # Variables used in interpolation in time
        cdef DTYPE_FLOAT_t time_fraction

        # Particle k layers
        cdef DTYPE_INT_t k_layer = particle.get_k_layer()
        cdef DTYPE_INT_t k_lower_layer = particle.get_k_lower_layer()
        cdef DTYPE_INT_t k_upper_layer = particle.get_k_upper_layer()

        # Interpolated values on lower and upper bounding sigma layers
        cdef DTYPE_FLOAT_t var_lower_layer
        cdef DTYPE_FLOAT_t var_upper_layer

        # The value of Ah to be returned
        cdef DTYPE_FLOAT_t Ah

        if self._Ah_method == 1:
            # Time fraction
            time_fraction = interp.get_linear_fraction_safe(time, self._time_last, self._time_next)

            if (particle.get_in_surface_boundary_layer() is True or particle.get_in_bottom_boundary_layer() is True):
                Ah = self._unstructured_grid_rho.interpolate_in_time_and_space(self._ah_last,
                                                                               self._ah_next,
                                                                               k_layer,
                                                                               time_fraction, particle)
            else:
                var_lower_layer = self._unstructured_grid_rho.interpolate_in_time_and_space(self._ah_last,
                                                                                            self._ah_next,
                                                                                            k_lower_layer,
                                                                                            time_fraction, particle)

                var_upper_layer = self._unstructured_grid_rho.interpolate_in_time_and_space(self._ah_last,
                                                                                            self._ah_next,
                                                                                            k_upper_layer,
                                                                                            time_fraction, particle)

                Ah = interp.linear_interp(particle.get_omega_layers(), var_lower_layer, var_upper_layer)
        else:
            raise RuntimeError('This dataset does not contain horizontal eddy viscosities.')

        return Ah

    cdef void get_horizontal_eddy_diffusivity_derivative(self, DTYPE_FLOAT_t time,
            Particle* particle, DTYPE_FLOAT_t Ah_prime[2]) except +:
        """ Returns the gradient in the horizontal eddy diffusivity

        Parameters
        ----------
        time : float
            Time at which to interpolate.
        
        particle: *Particle
            Pointer to a Particle object.

        Ah_prime : C array, float
            dAh_dx and dH_dy components stored in a C array of length two.  

        References
        ----------
        Lynch, D. R. et al (2014). Particles in the coastal ocean: theory and
        applications. Cambridge: Cambridge University Press.
        doi.org/10.1017/CBO9781107449336
        """
        # Variables used in interpolation in time
        cdef DTYPE_FLOAT_t time_fraction

        # Particle k_layer
        cdef DTYPE_INT_t k_layer = particle.get_k_layer()
        cdef DTYPE_INT_t k_lower_layer = particle.get_k_lower_layer()
        cdef DTYPE_INT_t k_upper_layer = particle.get_k_upper_layer()

        # Gradients on lower and upper layers
        cdef DTYPE_FLOAT_t grad_lower_layer[2]
        cdef DTYPE_FLOAT_t grad_upper_layer[2]

        if self._Ah_method == 1:
            # Time fraction
            time_fraction = interp.get_linear_fraction_safe(time, self._time_last, self._time_next)

            # No vertical interpolation for particles near to the surface or bottom,
            # i.e. above or below the top or bottom sigma layer depths respectively.
            if (particle.get_in_surface_boundary_layer() is True or particle.get_in_bottom_boundary_layer() is True):
                self._unstructured_grid_rho.interpolate_grad_in_time_and_space(self._ah_last,
                                                                               self._ah_next,
                                                                               k_layer,
                                                                               time_fraction, particle,
                                                                               Ah_prime)
            else:
                self._unstructured_grid_rho.interpolate_grad_in_time_and_space(self._ah_last,
                                                                               self._ah_next,
                                                                               k_lower_layer,
                                                                               time_fraction, particle,
                                                                               grad_lower_layer)

                self._unstructured_grid_rho.interpolate_grad_in_time_and_space(self._ah_last,
                                                                               self._ah_next,
                                                                               k_upper_layer,
                                                                               time_fraction, particle,
                                                                               grad_upper_layer)

                Ah_prime[0] = interp.linear_interp(particle.get_omega_layers(), grad_lower_layer[0], grad_upper_layer[0])
                Ah_prime[1] = interp.linear_interp(particle.get_omega_layers(), grad_lower_layer[1], grad_upper_layer[1])
        else:
            raise RuntimeError('This dataset does not contain horizontal eddy viscosities.')

        return

    cdef DTYPE_FLOAT_t get_vertical_eddy_diffusivity(self, DTYPE_FLOAT_t time,
            Particle* particle) except FLOAT_ERR:
        """ Returns the vertical eddy diffusivity through linear interpolation.

        Parameters
        ----------
        time : float
            Time at which to interpolate.
        
        particle: *Particle
            Pointer to a Particle object.
        
        Returns
        -------
        Kz : float
            The vertical eddy diffusivity.        
        
        """
        # Variables used in interpolation in time
        cdef DTYPE_FLOAT_t time_fraction

        # Particle k_layer
        cdef DTYPE_INT_t k_layer = particle.get_k_layer()


        # Interpolated values on lower and upper bounding w grid levels
        cdef DTYPE_FLOAT_t var_lower_level
        cdef DTYPE_FLOAT_t var_upper_level

        # The value of Kz to be returned
        cdef DTYPE_FLOAT_t Kz

        if self._Kz_method == 1:

            # Time fraction
            time_fraction = interp.get_linear_fraction_safe(time, self._time_last, self._time_next)

            # Variable on bounding levels
            var_level_1 = self._unstructured_grid_rho.interpolate_in_time_and_space(self._Kz_last,
                                                                                    self._Kz_next,
                                                                                    k_layer+1,
                                                                                    time_fraction, particle)

            var_level_2 = self._unstructured_grid_rho.interpolate_in_time_and_space(self._Kz_last,
                                                                                    self._Kz_next,
                                                                                    k_layer,
                                                                                    time_fraction, particle)

            Kz = interp.linear_interp(particle.get_omega_interfaces(), var_level_1, var_level_2)
        else:
            raise RuntimeError('This dataset does not contain vertical eddy diffusivities.')

        return Kz


    cdef DTYPE_FLOAT_t get_vertical_eddy_diffusivity_derivative(self,
        DTYPE_FLOAT_t time, Particle* particle) except FLOAT_ERR:
        """ Returns the gradient in the vertical eddy diffusivity.
        
        Return a numerical approximation of the gradient in the vertical eddy 
        diffusivity at (t,x,y,z) using central differencing. First, the
        diffusivity is computed on the depth levels bounding the particle.
        Central differencing is then used to compute the gradient in the
        diffusivity on these levels. Finally, the gradient in the diffusivity
        is interpolated to the particle's exact position. This algorithm
        mirrors that used in GOTMDataReader, which is why it has been implemented
        here. However, in contrast to GOTMDataReader, which calculates the
        gradient in the diffusivity at all levels once each simulation time step,
        resulting in significant time savings, this function is executed once
        for each particle. It is thus quite costly! To make things worse, the 
        code, as implemented here, is highly repetitive, and no doubt efficiency
        savings could be found. 

        Parameters
        ----------
        time : float
            Time at which to interpolate.
        
        particle: *Particle
            Pointer to a Particle object.
        
        Returns
        -------
        k_prime : float
            Gradient in the vertical eddy diffusivity field.
        """
        # Variables used in interpolation in time
        cdef DTYPE_FLOAT_t time_fraction

        # Containers for Kz and z
        cdef vector[DTYPE_FLOAT_t] Kz
        cdef vector[DTYPE_FLOAT_t] z

        # Gradient at bounding levels
        cdef DTYPE_FLOAT_t dKz_lower_level, dKz_upper_level

        # Particle k_layer
        cdef DTYPE_INT_t k_layer = particle.get_k_layer()
        cdef DTYPE_INT_t k, layer

        # The value of dKz_dz to be returned
        cdef DTYPE_FLOAT_t dKz_dz

        if self._Kz_method == 1:
            # Time fraction
            time_fraction = interp.get_linear_fraction_safe(time, self._time_last, self._time_next)

            if k_layer == 0:
                for k in xrange(3):
                    Kz.push_back(self._unstructured_grid_rho.interpolate_in_time_and_space(self._Kz_last,
                                                                                           self._Kz_next,
                                                                                           k_layer+k,
                                                                                           time_fraction, particle))

                    z.push_back(self._unstructured_grid_rho.interpolate_in_time_and_space(self._depth_levels_grid_w_last,
                                                                                          self._depth_levels_grid_w_next,
                                                                                          k_layer+k,
                                                                                          time_fraction, particle))

                dKz_lower_level = (Kz[0] - Kz[2]) / (z[0] - z[2])
                dKz_upper_level = (Kz[0] - Kz[1]) / (z[0] - z[1])

            elif k_layer == self._n_s_rho - 1:
                for k in xrange(3):
                    Kz.push_back(self._unstructured_grid_rho.interpolate_in_time_and_space(self._Kz_last,
                                                                                           self._Kz_next,
                                                                                           k_layer - 1 + k,
                                                                                           time_fraction, particle))

                    z.push_back(self._unstructured_grid_rho.interpolate_in_time_and_space(self._depth_levels_grid_w_last,
                                                                                          self._depth_levels_grid_w_next,
                                                                                          k_layer - 1 + k,
                                                                                          time_fraction, particle))

                dKz_lower_level = (Kz[1] - Kz[2]) / (z[1] - z[2])
                dKz_upper_level = (Kz[0] - Kz[2]) / (z[0] - z[2])

            else:
                for k in xrange(4):
                    Kz.push_back(self._unstructured_grid_rho.interpolate_in_time_and_space(self._Kz_last,
                                                                                           self._Kz_next,
                                                                                           k_layer - 1 + k,
                                                                                           time_fraction, particle))

                    z.push_back(self._unstructured_grid_rho.interpolate_in_time_and_space(self._depth_levels_grid_w_last,
                                                                                          self._depth_levels_grid_w_next,
                                                                                          k_layer - 1 + k,
                                                                                          time_fraction, particle))

                dKz_lower_level = (Kz[1] - Kz[3]) / (z[1] - z[3])
                dKz_upper_level = (Kz[0] - Kz[2]) / (z[0] - z[2])

            dKz_dz = interp.linear_interp(particle.get_omega_interfaces(), dKz_lower_level, dKz_upper_level)
        else:
            raise RuntimeError('This dataset does not contain vertical eddy diffusivities.')

        return dKz_dz

    cdef DTYPE_INT_t is_wet(self, DTYPE_FLOAT_t time, Particle *particle) except INT_ERR:
        """ Return an integer indicating whether `host' is wet or dry
        
        The function returns 1 if `host' is wet at time `time' and 
        0 if `host' is dry.
        
        The wet-dry distinction reflects two discrete states - either the
        element is wet, or it is dry. This raises the question of how to deal
        with intermediate times, such that td < t < tw where
        t is the current model time, and td and tw are conescutive input time
        points between which the host element switches from being dry to being
        wet. The approach taken is conservative, and involves flagging the
        element as being dry if either one or both of the input time points
        bounding the current model time indicate that the element is dry. In this
        simple procedure, the `time' parameter is actually unused.
        
        NB - just because an element is flagged as being dry does not mean
        that particles are necessarily frozen. Clients can still try to advect
        particles within such elements, and the interpolated velocity field may
        yield non-zero values, depending on the state of the host and
        surrounding elements in the given time window.

        Parameters
        ----------
        time : float
            Time (unused)

        host : int
            Integer that identifies the host element in question
        """
        cdef DTYPE_INT_t host_element = particle.get_host_horizontal_elem(self._name_grid_rho)

        if self._has_is_wet:
            if self._wet_cells_last[host_element] == 0 or self._wet_cells_next[host_element] == 0:
                return 0
        return 1

    def _read_grid(self):
        """ Set grid and coordinate variables.
        
        All communications go via the mediator in order to guarantee support for
        both serial and parallel simulations.
        
        Parameters
        ----------
        N/A
        
        Returns
        -------
        N/A
        """
        # Read in the grid's dimensions
        self._n_longitude_grid_u = self.mediator.get_dimension_variable('longitude_grid_u')
        self._n_longitude_grid_v = self.mediator.get_dimension_variable('longitude_grid_v')
        self._n_longitude_grid_rho = self.mediator.get_dimension_variable('longitude_grid_rho')
        self._n_longitude_grid_psi = self.mediator.get_dimension_variable('longitude_grid_psi')

        self._n_latitude_grid_u = self.mediator.get_dimension_variable('latitude_grid_u')
        self._n_latitude_grid_v = self.mediator.get_dimension_variable('latitude_grid_v')
        self._n_latitude_grid_rho = self.mediator.get_dimension_variable('latitude_grid_rho')
        self._n_latitude_grid_psi = self.mediator.get_dimension_variable('latitude_grid_psi')

        self._n_nodes_grid_u = self.mediator.get_dimension_variable('node_grid_u')
        self._n_nodes_grid_v = self.mediator.get_dimension_variable('node_grid_v')
        self._n_nodes_grid_rho = self.mediator.get_dimension_variable('node_grid_rho')
        self._n_nodes_grid_psi = self.mediator.get_dimension_variable('node_grid_psi')

        self._n_elems_grid_u = self.mediator.get_dimension_variable('element_grid_u')
        self._n_elems_grid_v = self.mediator.get_dimension_variable('element_grid_v')
        self._n_elems_grid_rho = self.mediator.get_dimension_variable('element_grid_rho')
        self._n_elems_grid_psi = self.mediator.get_dimension_variable('element_grid_psi')

        self._n_s_rho = self.mediator.get_dimension_variable('s_rho')
        self._n_s_w = self.mediator.get_dimension_variable('s_w')

        # Grid connectivity/adjacency
        self._nv_grid_u = self.mediator.get_grid_variable('nv_grid_u', (3, self._n_elems_grid_u), DTYPE_INT)
        self._nv_grid_v = self.mediator.get_grid_variable('nv_grid_v', (3, self._n_elems_grid_v), DTYPE_INT)
        self._nv_grid_rho = self.mediator.get_grid_variable('nv_grid_rho', (3, self._n_elems_grid_rho), DTYPE_INT)
        self._nv_grid_psi = self.mediator.get_grid_variable('nv_grid_psi', (3, self._n_elems_grid_psi), DTYPE_INT)

        self._nbe_grid_u = self.mediator.get_grid_variable('nbe_grid_u', (3, self._n_elems_grid_u), DTYPE_INT)
        self._nbe_grid_v = self.mediator.get_grid_variable('nbe_grid_v', (3, self._n_elems_grid_v), DTYPE_INT)
        self._nbe_grid_rho = self.mediator.get_grid_variable('nbe_grid_rho', (3, self._n_elems_grid_rho), DTYPE_INT)
        self._nbe_grid_psi = self.mediator.get_grid_variable('nbe_grid_psi', (3, self._n_elems_grid_psi), DTYPE_INT)

        # Grid angles
        if self._grid_type == 'curvilinear':
            try:
                self._rho_angles =  self.mediator.get_grid_variable('angles_grid_rho', (self._n_nodes_grid_rho), DTYPE_FLOAT)
            except KeyError:
                print('For curvilinear grids, grid angles at rho points must be provided via the grid metrics file.')
                raise


        # Raw grid x/y or lat/lon coordinates
        coordinate_system = self.config.get("SIMULATION", "coordinate_system").strip().lower()

        if coordinate_system == "geographic":
            x_grid_u = self.mediator.get_grid_variable('longitude_grid_u', (self._n_nodes_grid_u), DTYPE_FLOAT) * deg_to_radians
            y_grid_u = self.mediator.get_grid_variable('latitude_grid_u', (self._n_nodes_grid_u), DTYPE_FLOAT) * deg_to_radians
            xc_grid_u = self.mediator.get_grid_variable('longitude_c_grid_u', (self._n_elems_grid_u), DTYPE_FLOAT) * deg_to_radians
            yc_grid_u = self.mediator.get_grid_variable('latitude_c_grid_u', (self._n_elems_grid_u), DTYPE_FLOAT) * deg_to_radians

            x_grid_v = self.mediator.get_grid_variable('longitude_grid_v', (self._n_nodes_grid_v), DTYPE_FLOAT) * deg_to_radians
            y_grid_v = self.mediator.get_grid_variable('latitude_grid_v', (self._n_nodes_grid_v), DTYPE_FLOAT) * deg_to_radians
            xc_grid_v = self.mediator.get_grid_variable('longitude_c_grid_v', (self._n_elems_grid_v), DTYPE_FLOAT) * deg_to_radians
            yc_grid_v = self.mediator.get_grid_variable('latitude_c_grid_v', (self._n_elems_grid_v), DTYPE_FLOAT) * deg_to_radians

            x_grid_rho = self.mediator.get_grid_variable('longitude_grid_rho', (self._n_nodes_grid_rho), DTYPE_FLOAT) * deg_to_radians
            y_grid_rho = self.mediator.get_grid_variable('latitude_grid_rho', (self._n_nodes_grid_rho), DTYPE_FLOAT) * deg_to_radians
            xc_grid_rho = self.mediator.get_grid_variable('longitude_c_grid_rho', (self._n_elems_grid_rho), DTYPE_FLOAT) * deg_to_radians
            yc_grid_rho = self.mediator.get_grid_variable('latitude_c_grid_rho', (self._n_elems_grid_rho), DTYPE_FLOAT) * deg_to_radians

            x_grid_psi = self.mediator.get_grid_variable('longitude_grid_psi', (self._n_nodes_grid_psi), DTYPE_FLOAT) * deg_to_radians
            y_grid_psi = self.mediator.get_grid_variable('latitude_grid_psi', (self._n_nodes_grid_psi), DTYPE_FLOAT) * deg_to_radians
            xc_grid_psi = self.mediator.get_grid_variable('longitude_c_grid_psi', (self._n_elems_grid_psi), DTYPE_FLOAT) * deg_to_radians
            yc_grid_psi = self.mediator.get_grid_variable('latitude_c_grid_psi', (self._n_elems_grid_psi), DTYPE_FLOAT) * deg_to_radians

            # Don't apply offsets in geographic case - set them to 0.0!
            self._xmin = 0.0
            self._ymin = 0.0
        else:
            raise ValueError("Unsupported model coordinate system `{}'".format(coordinate_system))

        # Land sea mask - elements. Psi grid only for now. U/V/rho grids initialised to be all sea points.
        self._mask_c_grid_u = np.zeros(self._n_elems_grid_u, dtype=DTYPE_INT)
        self._mask_c_grid_v = np.zeros(self._n_elems_grid_v, dtype=DTYPE_INT)
        self._mask_c_grid_rho = np.zeros(self._n_elems_grid_rho, dtype=DTYPE_INT)
        self._mask_c_grid_psi = self.mediator.get_grid_variable('mask_c_grid_psi', (self._n_elems_grid_psi), DTYPE_INT)

        # Land sea mask - nodes. All sea points - masking is done through the psi grid element mask.
        self._mask_grid_u = np.zeros(self._n_nodes_grid_u, dtype=DTYPE_INT)
        self._mask_grid_v = np.zeros(self._n_nodes_grid_v, dtype=DTYPE_INT)
        self._mask_grid_rho = np.zeros(self._n_nodes_grid_rho, dtype=DTYPE_INT)
        self._mask_grid_psi = np.zeros(self._n_nodes_grid_psi, dtype=DTYPE_INT)

        # Initialise the unstructured grids objects
        if self._grid_type == 'rectilinear':
            # Use native U and V grids
            self._unstructured_grid_u = get_unstructured_grid(self.config, self._name_grid_u, self._n_nodes_grid_u,
                                                              self._n_elems_grid_u, self._nv_grid_u, self._nbe_grid_u,
                                                              x_grid_u, y_grid_u, xc_grid_u, yc_grid_u,
                                                              self._mask_c_grid_u, self._mask_grid_u)

            self._unstructured_grid_v = get_unstructured_grid(self.config, self._name_grid_v, self._n_nodes_grid_v,
                                                              self._n_elems_grid_v, self._nv_grid_v, self._nbe_grid_v,
                                                              x_grid_v, y_grid_v, xc_grid_v, yc_grid_v,
                                                              self._mask_c_grid_v, self._mask_grid_v)
        elif  self._grid_type == 'curvilinear':
            # Use rho grid for u/v velocity components. These will be remapped onto the rho grid as they are read in.
            self._unstructured_grid_u = get_unstructured_grid(self.config, self._name_grid_u, self._n_nodes_grid_rho,
                                                              self._n_elems_grid_rho, self._nv_grid_rho, self._nbe_grid_rho,
                                                              x_grid_rho, y_grid_rho, xc_grid_rho, yc_grid_rho,
                                                              self._mask_c_grid_rho, self._mask_grid_rho)

            self._unstructured_grid_v = get_unstructured_grid(self.config, self._name_grid_v, self._n_nodes_grid_rho,
                                                              self._n_elems_grid_rho, self._nv_grid_rho, self._nbe_grid_rho,
                                                              x_grid_rho, y_grid_rho, xc_grid_rho, yc_grid_rho,
                                                              self._mask_c_grid_rho, self._mask_grid_rho)

        self._unstructured_grid_rho = get_unstructured_grid(self.config, self._name_grid_rho, self._n_nodes_grid_rho,
                                                            self._n_elems_grid_rho, self._nv_grid_rho, self._nbe_grid_rho,
                                                            x_grid_rho, y_grid_rho, xc_grid_rho, yc_grid_rho,
                                                            self._mask_c_grid_rho, self._mask_grid_rho)

        self._unstructured_grid_psi = get_unstructured_grid(self.config, self._name_grid_psi, self._n_nodes_grid_psi,
                                                            self._n_elems_grid_psi, self._nv_grid_psi, self._nbe_grid_psi,
                                                            x_grid_psi, y_grid_psi, xc_grid_psi, yc_grid_psi,
                                                            self._mask_c_grid_psi, self._mask_grid_psi)

        # Read in depth vars
        self._s_rho = self.mediator.get_grid_variable('s_rho', (self._n_s_rho), DTYPE_FLOAT)
        self._s_w = self.mediator.get_grid_variable('s_w', (self._n_s_w), DTYPE_FLOAT)
        self._cs_r = self.mediator.get_grid_variable('cs_r', (self._n_s_rho), DTYPE_FLOAT)
        self._cs_w = self.mediator.get_grid_variable('cs_w', (self._n_s_w), DTYPE_FLOAT)
        self._hc = self.mediator.get_grid_variable('hc', (1), DTYPE_FLOAT)

        # Vertical transform used when constructing depth grid
        self._vtransform = int(self.mediator.get_grid_variable('vtransform', (1), DTYPE_FLOAT))
        if self._vtransform < 1 or self._vtransform > 2:
            raise ValueError('Unsupported vertical transform {}'.format(self._vtransform))

        # Orientation of vertical variables
        self._flip_vertical_axis = False
        if self._s_rho[0] < self._s_rho[self._n_s_rho-1]:
            self._flip_vertical_axis = True

        # Bathymetry
        self._h = self.mediator.get_grid_variable('h', (self._n_nodes_grid_rho), DTYPE_FLOAT)

        # Add zeta to shape and dimension indices to dictionaries
        if self._has_zeta:
            self._variable_shapes['zos'] = self.mediator.get_variable_shape(self._variable_names['zos'],
                                                                            include_time=False)
            dimensions = self.mediator.get_variable_dimensions(self._variable_names['zos'],
                                                               include_time=False)
            self._variable_dimension_indices['zos'] = {'latitude_grid_rho': dimensions.index(self._dimension_names['latitude_grid_rho']),
                                                       'longitude_grid_rho': dimensions.index(self._dimension_names['longitude_grid_rho'])}

        # Add is wet/dry mask shape and dimension indices to dictionaries
        if self._has_is_wet:
            self._variable_shapes['wetdry_mask_rho'] = self.mediator.get_variable_shape(self._variable_names['wetdry_mask_rho'],
                                                                                        include_time=False)
            dimensions = self.mediator.get_variable_dimensions(self._variable_names['wetdry_mask_rho'],
                                                               include_time=False)
            self._variable_dimension_indices['wetdry_mask_rho'] = {'latitude_grid_rho': dimensions.index(self._dimension_names['latitude_grid_rho']),
                                                                   'longitude_grid_rho': dimensions.index(self._dimension_names['longitude_grid_rho'])}

        # Add 3D vars to shape and dimension indices dictionaries
        var_names = ['uo', 'vo']
        grid_names = ['grid_u', 'grid_v']
        depth_grid_names = ['grid_rho', 'grid_rho']

        # Vertical velocity
        if self._has_w:
            var_names.append('wo')
            grid_names.append('grid_rho')
            depth_grid_names.append('grid_w')

        # Vertical diffusion coefficient
        if self._Kz_method == 1:
            var_names.append('Kz')
            grid_names.append('grid_rho')
            depth_grid_names.append('grid_w')

        # Horizontal diffusion coefficient
        if self._Ah_method == 1:
            var_names.append('Ah')
            grid_names.append('grid_rho')
            depth_grid_names.append('grid_rho')

        # Temperature
        if 'thetao' in self.env_var_names:
            var_names.append('thetao')
            grid_names.append('grid_rho')
            depth_grid_names.append('grid_rho')

        # Salinity
        if 'so' in self.env_var_names:
            var_names.append('so')
            grid_names.append('grid_rho')
            depth_grid_names.append('grid_rho')

        # Construct dictionary of variable shapes and dimension indices
        for var_name, grid_name, depth_grid_name in zip(var_names, grid_names, depth_grid_names):
            self._variable_shapes[var_name] = self.mediator.get_variable_shape(self._variable_names[var_name],
                                                                               include_time=False)
            dimensions = self.mediator.get_variable_dimensions(self._variable_names[var_name],
                                                               include_time=False)
            self._variable_dimension_indices[var_name] = {'depth': dimensions.index(self._dimension_names['depth_{}'.format(depth_grid_name)]),
                                                          'latitude': dimensions.index(self._dimension_names['latitude_{}'.format(grid_name)]),
                                                          'longitude': dimensions.index(self._dimension_names['longitude_{}'.format(grid_name)])}

    cdef _read_time_dependent_vars(self):
        """ Update time variables and memory views for data fields.
        
        For each time-dependent variable needed by PyLag two references
        are stored. These correspond to the last and next time points at which
        data was saved. Together these bound PyLag's current time point.
        
        All communications go via the mediator in order to guarantee support for
        both serial and parallel simulations.
        
        Parameters
        ----------
        N/A
        
        Returns
        -------
        N/A
        """
        cdef DTYPE_INT_t i, j, k
        cdef DTYPE_INT_t node
        cdef DTYPE_INT_t is_wet_last, is_wet_next

        # Update time references
        self._time_last = self.mediator.get_time_at_last_time_index()
        self._time_next = self.mediator.get_time_at_next_time_index()

        # Update memory views for zeta
        if self._has_zeta:
            zeta_var_name = self._variable_names['zos']

            # Zeta at last time step
            zeta_last = self.mediator.get_time_dependent_variable_at_last_time_index(zeta_var_name,
                    self._variable_shapes['zos'], DTYPE_FLOAT)
            self._zeta_last = self._reshape_var(zeta_last, self._variable_dimension_indices['zos'])

            # Zeta at next time step
            zeta_next = self.mediator.get_time_dependent_variable_at_next_time_index(zeta_var_name,
                    self._variable_shapes['zos'], DTYPE_FLOAT)
            self._zeta_next = self._reshape_var(zeta_next, self._variable_dimension_indices['zos'])
        else:
            # If zeta wasn't given, set it to zero throughout
            self._zeta_last = np.zeros((self._n_nodes_grid_rho), dtype=DTYPE_FLOAT)
            self._zeta_next = np.zeros((self._n_nodes_grid_rho), dtype=DTYPE_FLOAT)

        # Update depth levels
        self._depth_levels_grid_rho_last = self.compute_depths('grid_rho', self._h, self._zeta_last)
        self._depth_levels_grid_rho_next = self.compute_depths('grid_rho', self._h, self._zeta_next)
        self._depth_levels_grid_w_last = self.compute_depths('grid_w', self._h, self._zeta_last)
        self._depth_levels_grid_w_next = self.compute_depths('grid_w', self._h, self._zeta_next)

        # Update memory views for u
        u_var_name = self._variable_names['uo']
        u_last = self.mediator.get_time_dependent_variable_at_last_time_index(u_var_name,
                self._variable_shapes['uo'], DTYPE_FLOAT)

        u_next = self.mediator.get_time_dependent_variable_at_next_time_index(u_var_name,
                self._variable_shapes['uo'], DTYPE_FLOAT)

        # Update memory views for v
        v_var_name = self._variable_names['vo']
        v_last = self.mediator.get_time_dependent_variable_at_last_time_index(v_var_name,
                self._variable_shapes['vo'], DTYPE_FLOAT)

        v_next = self.mediator.get_time_dependent_variable_at_next_time_index(v_var_name,
                self._variable_shapes['vo'], DTYPE_FLOAT)

        if self._grid_type == 'rectilinear':
            self._u_last = self._reshape_var(u_last, self._variable_dimension_indices['uo'])
            self._u_next = self._reshape_var(u_next, self._variable_dimension_indices['uo'])
            self._v_last = self._reshape_var(v_last, self._variable_dimension_indices['vo'])
            self._v_next = self._reshape_var(v_last, self._variable_dimension_indices['vo'])
        if self._grid_type == 'curvilinear':
            # Shift the velocity components to rho points
            # TODO assumes standard ROMS variable ordering (t, k. j, i)
            u_last = self.u_to_rho(u_last)
            u_next = self.u_to_rho(u_next)
            v_last = self.v_to_rho(v_last)
            v_next = self.v_to_rho(v_next)

            # Reshape and store
            dimension_indices = {'depth': 0, 'latitude': 1, 'longitude': 2}
            u_last = self._reshape_var(u_last, dimension_indices)
            u_next = self._reshape_var(u_next, dimension_indices)
            v_last = self._reshape_var(v_last, dimension_indices)
            v_next = self._reshape_var(v_next, dimension_indices)

            # Rotate vector
            self._u_last, self._v_last = self.rotate_vector(u_last, v_last, self._rho_angles)
            self._u_next, self._v_next = self.rotate_vector(u_next, v_next, self._rho_angles)

        # Update memory views for w
        if self._has_w:
            w_var_name = self._variable_names['wo']
            w_last = self.mediator.get_time_dependent_variable_at_last_time_index(w_var_name,
                    self._variable_shapes['wo'], DTYPE_FLOAT)
            self._w_last = self._reshape_var(w_last, self._variable_dimension_indices['wo'])

            w_next = self.mediator.get_time_dependent_variable_at_next_time_index(w_var_name,
                    self._variable_shapes['wo'], DTYPE_FLOAT)
            self._w_next = self._reshape_var(w_next, self._variable_dimension_indices['wo'])

        # Update memory views for Kz
        if self._Kz_method == 1:
            Kz_var_name = self._variable_names['Kz']
            Kz_last = self.mediator.get_time_dependent_variable_at_last_time_index(Kz_var_name,
                    self._variable_shapes['Kz'], DTYPE_FLOAT)
            self._Kz_last = self._reshape_var(Kz_last, self._variable_dimension_indices['Kz'])

            Kz_next = self.mediator.get_time_dependent_variable_at_next_time_index(Kz_var_name,
                    self._variable_shapes['Kz'], DTYPE_FLOAT)
            self._Kz_next = self._reshape_var(Kz_next, self._variable_dimension_indices['Kz'])

        # Update memory views for Ah
        if self._Ah_method == 1:
            ah_var_name = self._variable_names['Ah']
            ah_last = self.mediator.get_time_dependent_variable_at_last_time_index(ah_var_name,
                    self._variable_shapes['Ah'], DTYPE_FLOAT)
            self._ah_last = self._reshape_var(ah_last, self._variable_dimension_indices['Ah'])

            ah_next = self.mediator.get_time_dependent_variable_at_next_time_index(ah_var_name,
                    self._variable_shapes['Ah'], DTYPE_FLOAT)
            self._ah_next = self._reshape_var(ah_next, self._variable_dimension_indices['Ah'])

        # Set is wet status
        # The wet/dry status is
        if self._has_is_wet:
            wetdry_mask_var_name = self._variable_names['wetdry_mask_rho']
            wetdry_mask_last = self.mediator.get_time_dependent_variable_at_last_time_index(wetdry_mask_var_name,
                    self._variable_shapes['wetdry_mask_rho'], DTYPE_FLOAT)
            wetdry_mask_last = self._reshape_var(wetdry_mask_last, self._variable_dimension_indices['wetdry_mask_rho'])

            wetdry_mask_next = self.mediator.get_time_dependent_variable_at_next_time_index(wetdry_mask_var_name,
                    self._variable_shapes['wetdry_mask_rho'], DTYPE_FLOAT)
            wetdry_mask_next = self._reshape_var(wetdry_mask_next, self._variable_dimension_indices['wetdry_mask_rho'])

            for i in xrange(self._n_elems_grid_rho):
                if self._mask_c_grid_rho[i] == 0:
                    is_wet_last = 1
                    is_wet_next = 1
                    for j in xrange(3):
                        node = self._nv_grid_rho[j, i]
                        if wetdry_mask_last[node] == 1:
                            is_wet_last = 0
                        if wetdry_mask_next[node] == 1:
                            is_wet_next = 0
                    self._wet_cells_last[i] = is_wet_last
                    self._wet_cells_next[i] = is_wet_next

        # Read in data as requested
        if 'thetao' in self.env_var_names:
            var_name = self._variable_names['thetao']
            thetao_next = self.mediator.get_time_dependent_variable_at_next_time_index(var_name,
                    self._variable_shapes['thetao'], DTYPE_FLOAT)
            self._thetao_next = self._reshape_var(thetao_next, self._variable_dimension_indices['thetao'])

            thetao_last = self.mediator.get_time_dependent_variable_at_last_time_index(var_name,
                    self._variable_shapes['thetao'], DTYPE_FLOAT)
            self._thetao_last = self._reshape_var(thetao_last, self._variable_dimension_indices['thetao'])

        if 'so' in self.env_var_names:
            var_name = self._variable_names['so']
            so_next = self.mediator.get_time_dependent_variable_at_next_time_index(var_name,
                    self._variable_shapes['so'], DTYPE_FLOAT)
            self._so_next = self._reshape_var(so_next, self._variable_dimension_indices['so'])

            so_last = self.mediator.get_time_dependent_variable_at_last_time_index(var_name,
                    self._variable_shapes['so'], DTYPE_FLOAT)
            self._so_last = self._reshape_var(so_last, self._variable_dimension_indices['so'])

        return

    def _reshape_var(self, var, dimension_indices):
        """ Reshape variable for PyLag

        Variables with the following dimensions are supported:

        2D - [lat, lon] in any order

        3D - [depth, lat, lon] in any order

        The lon/lat/depth key names should be specific to the grid on which the variable is
        defined.

        Parameters
        ----------
        var : NDArray
            The variable to sort

        dimension_indices : dict
            Dictionary of dimension indices

        Returns
        -------
        var_reshaped : NDArray
            Reshaped variable
        """
        n_dimensions = len(var.shape)

        if n_dimensions == 2:
            longitude_dim_name = self._get_dimension_name('longitude', dimension_indices.keys())
            lon_index = dimension_indices[longitude_dim_name]

            # Shift axes to give [x, y]
            var = np.moveaxis(var, lon_index, 0)

            return var.reshape(np.prod(var.shape), order='C')[:]

        elif n_dimensions == 3:
            depth_dim_name = self._get_dimension_name('depth', dimension_indices.keys())
            latitude_dim_name = self._get_dimension_name('latitude', dimension_indices.keys())
            longitude_dim_name = self._get_dimension_name('longitude', dimension_indices.keys())

            depth_index = dimension_indices[depth_dim_name]
            lat_index = dimension_indices[latitude_dim_name]
            lon_index = dimension_indices[longitude_dim_name]

            # Shift axes to give [z, x, y]
            var = np.moveaxis(var, depth_index, 0)

            # Update lat/lon indices if needed
            if depth_index > lat_index:
                lat_index += 1
            if depth_index > lon_index:
                lon_index += 1

            var = np.moveaxis(var, lon_index, 1)

            # Flip z axis?
            if self._flip_vertical_axis == True:
                var = np.flip(var, axis=0)

            return var.reshape(var.shape[0], np.prod(var.shape[1:]), order='C')[:]
        else:
            raise ValueError('Unsupported number of dimensions {}.'.format(n_dimensions))

    def _get_dimension_name(self, dimension, grid_dimension_names):
        """ Helper function for finding dimension names

        The function searches the list of grid dimension names in order to find
        the one that contains the string `dimension`. Once found, that grid dimension
        name is returned to the caller.

        Parameters
        ----------
        dimension : str
            Dimension string (e.g. longitude or latitude)

        grid_dimension_names : list[str]
            List of grid dimensions names (e.g. ['longitude_grid_rho', 'latitude_grid_rho', ...].
        """
        for grid_dimension_name in grid_dimension_names:
            if dimension in grid_dimension_name:
               return grid_dimension_name

        raise RuntimeError('Dimension {} not found in list of dimension names'.format(dimension))

    @cython.wraparound(True)
    def u_to_rho(self, u):
        """  Put the u field onto the rho field for the c-grid

        Function adapted from the seapy library (https://github.com/powellb/seapy/blob/master/seapy).

        Parameters
        ----------
        u : masked array like
            Input u field

        Returns
        -------
        rho : masked array
        """
        # Mask the array (mask values are now zeros)
        u = np.ma.masked_where(u==0.0, u)
        shp = np.array(u.shape)
        nshp = shp.copy()
        nshp[-1] = nshp[-1] + 1
        fore = np.product([shp[i] for i in np.arange(0, u.ndim - 1)]).astype(int)
        nfld = np.ones([fore, nshp[-1]])
        nfld[:, 1:-1] = 0.5 * \
            (u.reshape([fore, shp[-1]])[:, 0:-1].filled(np.nan) +
             u.reshape([fore, shp[-1]])[:, 1:].filled(np.nan))
        nfld[:, 0] = nfld[:, 1] + (nfld[:, 2] - nfld[:, 3])
        nfld[:, -1] = nfld[:, -2] + (nfld[:, -2] - nfld[:, -3])
        u = np.ma.fix_invalid(nfld.reshape(nshp), copy=False, fill_value=1e+37)
        return np.ascontiguousarray(u.filled(0.0))

    @cython.wraparound(True)
    def v_to_rho(self, v):
        """  Put the v field onto the rho field for the c-grid

        Function adapted from the seapy library (https://github.com/powellb/seapy/blob/master/seapy).

        Parameters
        ----------
        v : masked array like
            Input v field

        Returns
        -------
        rho : masked array
        """
        # Mask the array (mask values are now zeros)
        v = np.ma.masked_where(v==0.0, v)
        shp = np.array(v.shape)
        nshp = shp.copy()
        nshp[-2] = nshp[-2] + 1
        fore = np.product([shp[i] for i in np.arange(0, v.ndim - 2)]).astype(int)
        nfld = np.ones([fore, nshp[-2], nshp[-1]])
        nfld[:, 1:-1, :] = 0.5 * \
            (v.reshape([fore, shp[-2], shp[-1]])[:, 0:-1, :].filled(np.nan) +
             v.reshape([fore, shp[-2], shp[-1]])[:, 1:, :].filled(np.nan))
        nfld[:, 0, :] = nfld[:, 1, :] + (nfld[:, 2, :] - nfld[:, 3, :])
        nfld[:, -1, :] = nfld[:, -2, :] + (nfld[:, -2, :] - nfld[:, -3, :])
        v = np.ma.fix_invalid(nfld.reshape(nshp), copy=False, fill_value=1e+37)
        return np.ascontiguousarray(v.filled(0.0))

    def rotate_vector(self, u, v, angle):
        """ Rotate a vector field by the given angle

        Function adapted from the seapy library (https://github.com/powellb/seapy/blob/master/seapy).

        Parameters
        ----------
        u : array like
            Input u component

        v : array like
            Input v component

        angle : array like
            Input angle of rotation in radians

        Returns
        -------
        rotated_u, rotated_v : array
        """
        u = np.asanyarray(u)
        v = np.asanyarray(v)
        angle = np.asanyarray(angle)

        # Check array shapes
        assert u.shape == v.shape
        assert len(u.shape) == 2
        assert len(angle.shape) == 1

        # Tile angles in depth
        angle = np.tile(angle[np.newaxis, :], (u.shape[0], 1))

        sa = np.sin(angle)
        ca = np.cos(angle)

        return u * ca - v * sa, u * sa + v * ca

    def compute_depths(self, depth_grid, h, zeta):
        """ Compute depth levels

        Compute ROMS depth levels using h and zeta. Supports ROMS vertical coordinate transform
        option one and two. See ROMS documentation for more details.

        Parameters
        ----------
        depth_grid : str
            The depth grid. Options are `grid_rho` or `grid_w`.

        h : 1D memory view
            Bathymetry at nodes

        zeta : 1D memory view
            Sea surface elevation at nodes

        Returns
        -------
        depth : 2D NumPy NDArray
        """
        if depth_grid == 'grid_rho':
            cs = self._cs_r
            s = self._s_rho
            n_s = self._n_s_rho
        elif depth_grid == 'grid_w':
            cs = self._cs_w
            s = self._s_w
            n_s = self._n_s_w
        else:
            raise ValueError('Unrecognised vertical grid name {}'.format(depth_grid))

        # Tile vars to give matching array dims
        h_tiled = np.tile(h, (n_s, 1))
        zeta_tiled = np.tile(zeta, (n_s, 1))
        s = np.tile(s, (self._n_nodes_grid_rho, 1)).T
        cs = np.tile(cs, (self._n_nodes_grid_rho, 1)).T

        # Apply vertical transform
        if self._vtransform == 1:
            zo = self._hc * (s - cs) + cs * h_tiled
            z = zo + zeta_tiled * (1 + zo/h_tiled)
        elif self._vtransform == 2:
            zo = (self._hc * s + cs * h_tiled) / (self._hc + h_tiled)
            z = zeta_tiled + (zeta_tiled + h_tiled) * zo

        # Apply vertical flip?
        if self._flip_vertical_axis == True:
            z = np.flip(z, axis=0)

        return np.ascontiguousarray(z)
