"""
The FVCOM data reader should be used to read input data generated by FVCOM.

Note
----
fvcom_data_reader is implemented in Cython. Only a small portion of the
API is exposed in Python with accompanying documentation. However, more
details can be found in `pylag.data_reader`, where a set of python wrappers
have been implemented.
"""

include "constants.pxi"

import logging

try:
    import configparser
except ImportError:
    import ConfigParser as configparser

import numpy as np

from cpython cimport bool

# Data types used for constructing C data structures
from pylag.data_types_python import DTYPE_INT, DTYPE_FLOAT
from pylag.data_types_cython cimport DTYPE_INT_t, DTYPE_FLOAT_t

from libcpp.string cimport string
from libcpp.vector cimport vector
from libc.math cimport log

# PyLag cython imports
from pylag.parameters cimport cartesian, geographic, deg_to_radians
from pylag.particle cimport Particle
from pylag.particle_cpp_wrapper cimport to_string
from pylag.data_reader cimport DataReader
from pylag.unstructured cimport Grid
cimport pylag.interpolation as interp
from pylag.math cimport int_min, float_min

# PyLag python imports
from pylag import variable_library
from pylag.exceptions import PyLagValueError, PyLagRuntimeError
from pylag.numerics import get_time_direction
from pylag.unstructured import get_unstructured_grid


cdef class FVCOMDataReader(DataReader):
    """ DataReader for FVCOM input data
    
    Objects of type FVCOMDataReader are intended to manage all access to FVCOM 
    data objects, including data describing the model grid as well as FVCOM
    output variables. Provided are methods for searching the model grid for
    host horizontal elements and for interpolating gridded field data to
    a given point in space and time.
    
    Parameters
    ----------
    config : ConfigParser
        Configuration object.
    
    mediator : Mediator
        Mediator object for managing access to data read from file.
    """
    
    # Configurtion object
    cdef object config

    # Mediator for accessing FVCOM model data read in from file
    cdef object mediator

    # Unstructured grid object for performing grid searching etc
    cdef Grid _unstructured_grid

    # List of environmental variables to read and save
    cdef object env_var_names

    # The name of the grid
    cdef string _name

    # Integer flag for the coordinate system being used
    cdef DTYPE_INT_t _coordinate_system

    # Grid dimensions
    cdef DTYPE_INT_t _n_elems, _n_nodes, _n_siglay, _n_siglev
    
    # Element connectivity
    cdef DTYPE_INT_t[:,::1] _nv
    
    # Element adjacency
    cdef DTYPE_INT_t[:,::1] _nbe
    
    # Nodal coordinates
    cdef DTYPE_FLOAT_t[::1] _x
    cdef DTYPE_FLOAT_t[::1] _y

    # Element centre coordinates
    cdef DTYPE_FLOAT_t[::1] _xc
    cdef DTYPE_FLOAT_t[::1] _yc

    # Minimum nodal x/y values
    cdef DTYPE_FLOAT_t _xmin
    cdef DTYPE_FLOAT_t _ymin
    
#    # Interpolation coefficients
#    cdef DTYPE_FLOAT_t[:,:] _a1u
#    cdef DTYPE_FLOAT_t[:,:] _a2u

    # Sigma layers and levels
    cdef DTYPE_FLOAT_t[:, ::1] _siglev
    cdef DTYPE_FLOAT_t[:, ::1] _siglay

    # Depth of layer interfaces (i.e. levels), accounting for changes in sea surface elevation
    cdef DTYPE_FLOAT_t[:, ::1] _depth_levels_last
    cdef DTYPE_FLOAT_t[:, ::1] _depth_levels_next

    # Depth of layer centres, accounting for changes in sea surface elevation
    cdef DTYPE_FLOAT_t[:, ::1] _depth_layers_last
    cdef DTYPE_FLOAT_t[:, ::1] _depth_layers_next

    # Bathymetry
    cdef DTYPE_FLOAT_t[::1] _h
    
    # Sea surface elevation
    cdef DTYPE_FLOAT_t[::1] _zeta_last
    cdef DTYPE_FLOAT_t[::1] _zeta_next
    
    # u/v/w velocity components
    cdef DTYPE_FLOAT_t[:,::1] _u_last
    cdef DTYPE_FLOAT_t[:,::1] _u_next
    cdef DTYPE_FLOAT_t[:,::1] _v_last
    cdef DTYPE_FLOAT_t[:,::1] _v_next
    cdef DTYPE_FLOAT_t[:,::1] _w_last
    cdef DTYPE_FLOAT_t[:,::1] _w_next
    
    # Vertical eddy diffusivities
    cdef DTYPE_FLOAT_t[:,::1] _Kz_last
    cdef DTYPE_FLOAT_t[:,::1] _Kz_next
    
    # Horizontal eddy diffusivities
    cdef DTYPE_FLOAT_t[:,::1] _viscofh_last
    cdef DTYPE_FLOAT_t[:,::1] _viscofh_next

    # Wet/dry status of elements
    cdef DTYPE_INT_t[::1] _wet_cells_last
    cdef DTYPE_INT_t[::1] _wet_cells_next

    # Sea water potential temperature
    cdef DTYPE_FLOAT_t[:,::1] _thetao_last
    cdef DTYPE_FLOAT_t[:,::1] _thetao_next

    # Sea water salinity
    cdef DTYPE_FLOAT_t[:,::1] _so_last
    cdef DTYPE_FLOAT_t[:,::1] _so_next

    # Time direction
    cdef DTYPE_INT_t _time_direction

    # Time array
    cdef DTYPE_FLOAT_t _time_last
    cdef DTYPE_FLOAT_t _time_next

    # Options controlling velocity corrections near to surface and bottom boundaries
    cdef bint _correct_near_bottom_velocities

    # Bottom roughness parameter
    # TODO - Allow this to vary spatially?
    cdef DTYPE_FLOAT_t _z0

    # Options controlling the reading of eddy diffusivities
    cdef object _Kz_method_name, _Ah_method_name
    cdef DTYPE_INT_t _Kz_method, _Ah_method

    # Flags that identify whether a given variable should be read in
    cdef bint _has_is_wet

    # Land sea mask on elements (1 - sea point, 0 - land point)
    cdef DTYPE_INT_t[::1] _land_sea_mask_c
    cdef DTYPE_INT_t[::1] _land_sea_mask

    def __init__(self, config, mediator):
        self.config = config
        self.mediator = mediator

        self._name = b'fvcom'

        # Time direction
        self._time_direction = <int>get_time_direction(config)

        # Coordinate system
        coordinate_system = self.config.get("SIMULATION",
                                            "coordinate_system").strip().lower()
        if coordinate_system == "cartesian":
            self._coordinate_system = cartesian
        elif coordinate_system == "geographic":
            self._coordinate_system = geographic
        else:
            raise PyLagValueError(f"Unsupported model coordinate system "
                                  f"`{coordinate_system}'")

        # Set options for correcting near bottom velocities
        try:
            self._correct_near_bottom_velocities = self.config.getboolean("OCEAN_DATA",
                                                                          "apply_near_bottom_log_velocity_profile")
        except (configparser.NoOptionError) as e:
            self._correct_near_bottom_velocities = False

        if self._correct_near_bottom_velocities:
            try:
                self._z0 = self.config.getfloat("OCEAN_DATA",
                                                "z0")
            except (configparser.NoOptionError) as e:
                raise PyLagValueError(f"Missing required bottom roughness parameter `z0' for "
                                      f"near bottom velocity correction. This parameter is required "
                                      f"when `use_near_bottom_log_velocity_profile = True'.")
            
            # Ensure we have a sensible value for z0
            if self._z0 <= 0.0:
                raise PyLagValueError(f"Invalid value for bottom roughness parameter `z0'. "
                                      f"This parameter must be greater than zero. Received "
                                      f"z0 = {self._z0}.")

        # Set options for handling the vertical eddy diffusivity
        self._Kz_method_name = self.config.get('OCEAN_DATA',
                                               'Kz_method').strip().lower()
        if self._Kz_method_name not in ['none', 'file']:
            raise PyLagRuntimeError(f"Invalid option for `Kz_method` "
                                    f"({self._Kz_method_name}).")

        if self._Kz_method_name == "none":
            self._Kz_method = 0
        elif self._Kz_method_name == "file":
            self._Kz_method = 1

        # Set options for handling the horizontal eddy diffusivity
        self._Ah_method_name = self.config.get('OCEAN_DATA',
                                               'Ah_method').strip().lower()
        if self._Ah_method_name not in ['none', 'file']:
            raise PyLagRuntimeError(f"Invalid option for `Ah_method` "
                                    f"({self._Ah_method_name}).")

        if self._Ah_method_name == "none":
            self._Ah_method = 0
        elif self._Ah_method_name == "file":
            self._Ah_method = 1

        # Set flags from config
        self._has_is_wet = self.config.getboolean("OCEAN_DATA",
                                                  "has_is_wet")

        # Check to see if any environmental variables are being saved.
        try:
            env_var_names = self.config.get("OUTPUT",
                    "environmental_variables").strip().split(',')
        except (configparser.NoSectionError, configparser.NoOptionError) as e:
            env_var_names = []

        self.env_var_names = []
        for env_var_name in env_var_names:
            env_var_name = env_var_name.strip()
            if env_var_name is not None:
                if env_var_name in variable_library.fvcom_variable_names.keys():
                    self.env_var_names.append(env_var_name)
                else:
                    raise PyLagValueError(f"Received unsupported variable "
                                          f"{env_var_name}")

        self._read_grid()

        self._read_time_dependent_vars()

    cpdef get_grid_names(self):
        """ Return a list of grid names
        """
        return [self._name.decode()]

    cpdef setup_data_access(self, start_datetime, end_datetime):
        """ Set up access to time-dependent variables.
        
        Parameters
        ----------
        start_datetime : Datetime
            Datetime object corresponding to the simulation start time.
        
        end_datetime : Datetime
            Datetime object corresponding to the simulation end time.
        """
        self.mediator.setup_data_access(start_datetime, end_datetime)

        self._read_time_dependent_vars()

    cpdef read_data(self, DTYPE_FLOAT_t time):
        """ Read in time dependent variable data from file?
        
        `time` is used to test if new data should be read in from file. If this
        is the case, arrays containing time-dependent variable data are updated.
        
        Parameters
        ----------
        time : float
            The current time.
        """
        cdef DTYPE_FLOAT_t time_fraction

        time_fraction = interp.get_linear_fraction(time, self._time_last, self._time_next)
        if self._time_direction == 1:
            if time_fraction < 0.0 or time_fraction >= 1.0:
                self.mediator.update_reading_frames(time)
                self._read_time_dependent_vars()
        else:
            if time_fraction <= 0.0 or time_fraction > 1.0:
                self.mediator.update_reading_frames(time)
                self._read_time_dependent_vars()

    cdef DTYPE_INT_t find_host(self, Particle *particle_old,
                               Particle *particle_new) except INT_ERR:
        """ Returns the host horizontal element.
        
        This function first tries to find the new host horizontal element using
        a local search algorithm based on the new point's barycentric
        coordinates. This is relatively fast. However, it can incorrectly flag
        that a particle has left the domain when in-fact it hasn't. For this
        reason, when the local host element search indicates that a particle
        has left the domain, a check is performed based on the particle's
        pathline - if this crosses a known boundary, the particle is deemed
        to have left the domain.

        The function returns a flag that indicates whether or not the particle
        has been found within the domain. If it has, it's host element will 
        have been set appropriately. If not, the the new particle's host
        element will have been set to the last host element the particle passed
        through before exiting the domain.
        
        Conventions
        -----------
        flag = IN_DOMAIN:
            This indicates that the particle was found successfully. Host is the
            index of the new host element.
        
        flag = LAND_BDY_CROSSED:
            This indicates that the particle exited the domain across a land
            boundary. Host is set to the last element the particle passed
            through before exiting the domain.

        flag = OPEN_BDY_CROSSED:
            This indicates that the particle exited the domain across an open
            boundary. Host is set to the last element the particle passed
            through before exiting the domain.

        flag = IN_MASKED_ELEM:
            This indicated the particle is in the domain but the element it is
            in is masked. The flag is only returned by the local and global
            search algorithms. With FVCOM, this can only happen when the particle
            has entered an element with two land boundaries, which are flagged
            as masked elements during the generation of the grid metrics file.

        Parameters:
        -----------       
        particle_old: *Particle
            The particle at its old position.

        particle_new: *Particle
            The particle at its new position. The host element will be updated.
        
        Returns:
        --------
        flag : int
            Integer flag that indicates whether or not the seach was successful.
        """
        cdef DTYPE_INT_t flag, host

        # Save a copy of the current host, then use the old host to start a local search
        host = particle_new.get_host_horizontal_elem(self._name)
        particle_new.set_host_horizontal_elem(self._name, particle_old.get_host_horizontal_elem(self._name))
        flag = self._unstructured_grid.find_host_using_local_search(particle_new)

        if flag == IN_DOMAIN:
            return flag

        # Local search failed to find the particle. Perform check to see if
        # the particle has indeed left the model domain. Reset the host first
        # in order to preserve the original state of particle_new.
        particle_new.set_host_horizontal_elem(self._name, host)
        flag = self._unstructured_grid.find_host_using_particle_tracing(particle_old,
                                                                        particle_new)

        return flag

    cdef DTYPE_INT_t find_host_using_local_search(self, Particle *particle) except INT_ERR:
        """ Returns the host horizontal element through local searching.

        This function is a wrapper for the same function implemented in UnstructuredGrid.

        Parameters:
        -----------
        particle: *Particle
            The particle.

        Returns:
        --------
        flag : int
            Integer flag that indicates whether or not the seach was successful.
        """
        return self._unstructured_grid.find_host_using_local_search(particle)

    cdef DTYPE_INT_t find_host_using_global_search(self, Particle *particle) except INT_ERR:
        """ Returns the host horizontal element through global searching.

        This function is a wrapper for the same function implemented in UnstructuredGrid.

        Parameters:
        -----------
        particle_old: *Particle
            The particle.

        Returns:
        --------
        flag : int
            Integer flag that indicates whether or not the seach was successful.
        """
        return self._unstructured_grid.find_host_using_global_search(particle)

    cdef get_boundary_intersection(self,
                                   Particle *particle_old,
                                   Particle *particle_new,
                                   DTYPE_FLOAT_t start_point[2],
                                   DTYPE_FLOAT_t end_point[2],
                                   DTYPE_FLOAT_t intersection[2]):
        """ Find the boundary intersection point

        This function is a wrapper for the same function implemented in UnstructuredGrid.

        Parameters:
        -----------
        particle_old: *Particle
            The particle at its old position.

        particle_new: *Particle
            The particle at its new position.

        start_point : C array, float
            Start coordinates of the side the particle crossed.

        end_point : C array, float
            End coordinates of the side the particle crossed.

        intersection : C array, float
            Coordinates of the intersection point.

        Returns:
        --------
        """
        return self._unstructured_grid.get_boundary_intersection(particle_old, particle_new, start_point, end_point,
                                                                 intersection)

    cdef set_default_location(self, Particle *particle):
        """ Set default location

        Move the particle to its host element's centroid.
        """
        self._unstructured_grid.set_default_location(particle)

        return

    cdef set_local_coordinates(self, Particle *particle):
        """ Set local coordinates

        This function is a wrapper for the same function implemented in UnstructuredGrid.

        Parameters:
        -----------
        particle: *Particle
            Pointer to a Particle struct
        """
        self._unstructured_grid.set_local_coordinates(particle)

        return

    cdef DTYPE_INT_t set_vertical_grid_vars(self, DTYPE_FLOAT_t time,
                                            Particle *particle) except INT_ERR:
        """ Find the host depth layer
        
        Find the depth layer containing x3. In FVCOM, Sigma levels are counted
        up from 0 starting at the surface, where sigma = 0, and moving downwards
        to the sea floor where sigma = -1. The current sigma layer is
        found by determining the two sigma levels that bound the given z
        position. The computation works in terms of depths rather than sigma
        directly.
        """
        cdef DTYPE_FLOAT_t depth_upper_level, depth_lower_level
        cdef DTYPE_FLOAT_t depth_upper_layer, depth_lower_layer
        cdef DTYPE_FLOAT_t depth_test
        cdef DTYPE_FLOAT_t depth_particle

        cdef DTYPE_FLOAT_t time_fraction

        cdef DTYPE_INT_t k

        # Time fraction
        time_fraction = interp.get_linear_fraction_safe(time, self._time_last, self._time_next)

        # Particle depth
        depth_particle = particle.get_x3()

        # Loop over all levels
        depth_lower_level = self._unstructured_grid.interpolate_in_time_and_space(self._depth_levels_last,
                                                                                  self._depth_levels_next,
                                                                                  0,
                                                                                  time_fraction,
                                                                                  particle)
        for k in xrange(self._n_siglay):
            depth_upper_level = depth_lower_level
            depth_lower_level = self._unstructured_grid.interpolate_in_time_and_space(self._depth_levels_last,
                                                                                      self._depth_levels_next,
                                                                                      k+1,
                                                                                      time_fraction,
                                                                                      particle)

            if depth_particle <= depth_upper_level and depth_particle >= depth_lower_level:
                # Host layer found
                particle.set_k_layer(k)

                # Set the sigma level interpolation coefficient
                particle.set_omega_interfaces(interp.get_linear_fraction(depth_particle, depth_lower_level, depth_upper_level))

                # Set variables describing which half of the depth layer the
                # particle sits in and whether or not it resides in a boundary
                # layer
                depth_test = self._unstructured_grid.interpolate_in_time_and_space(self._depth_layers_last,
                                                                                   self._depth_layers_next,
                                                                                   k,
                                                                                   time_fraction,
                                                                                   particle)

                # Is x3 in the top or bottom boundary layer?
                if (k == 0 and depth_particle >= depth_test):
                    particle.set_in_surface_boundary_layer(True)
                    particle.set_in_bottom_boundary_layer(False)
                    return IN_DOMAIN
                elif (k == self._n_siglay - 1 and depth_particle <= depth_test):
                    particle.set_in_surface_boundary_layer(False)
                    particle.set_in_bottom_boundary_layer(True)
                    return IN_DOMAIN

                # x3 bounded by upper and lower depth layers
                particle.set_in_surface_boundary_layer(False)
                particle.set_in_bottom_boundary_layer(False)
                if depth_particle >= depth_test:
                    particle.set_k_upper_layer(k - 1)
                    particle.set_k_lower_layer(k)
                else:
                    particle.set_k_upper_layer(k)
                    particle.set_k_lower_layer(k + 1)

                # Set the sigma layer interpolation coefficient
                depth_lower_layer = self._unstructured_grid.interpolate_in_time_and_space(self._depth_layers_last,
                                                                                   self._depth_layers_next,
                                                                                   particle.get_k_lower_layer(),
                                                                                   time_fraction,
                                                                                   particle)

                depth_upper_layer = self._unstructured_grid.interpolate_in_time_and_space(self._depth_layers_last,
                                                                                   self._depth_layers_next,
                                                                                   particle.get_k_upper_layer(),
                                                                                   time_fraction,
                                                                                   particle)
                particle.set_omega_layers(interp.get_linear_fraction(depth_particle, depth_lower_layer, depth_upper_layer))

                return IN_DOMAIN

        return BDY_ERROR

    cpdef DTYPE_FLOAT_t get_xmin(self) except FLOAT_ERR:
        return self._xmin

    cpdef DTYPE_FLOAT_t get_ymin(self) except FLOAT_ERR:
        return self._ymin

    cdef DTYPE_FLOAT_t get_zmin(self, DTYPE_FLOAT_t time, Particle *particle) except FLOAT_ERR:
        """ Returns the bottom depth in cartesian coordinates

        h is defined at element nodes. Linear interpolation in space is used
        to compute h(x,y). NB the negative of h (which is +ve downwards) is
        returned.

        Parameters:
        -----------
        time : float
            Time.

        particle: *Particle
            Pointer to a Particle object.

        Returns:
        --------
        zmin : float
            The bottom depth.
        """
        cdef DTYPE_FLOAT_t h # Bathymetry at (x1, x2)

        h = self._unstructured_grid.interpolate_in_space(self._h, particle)

        return -h

    cdef DTYPE_FLOAT_t get_zmax(self, DTYPE_FLOAT_t time, Particle *particle) except FLOAT_ERR:
        """ Returns the sea surface height in cartesian coordinates

        zeta is defined at element nodes. Interpolation proceeds through linear
        interpolation time followed by interpolation in space.

        Parameters:
        -----------
        time : float
            Time.

        particle: *Particle
            Pointer to a Particle object.
        
        Returns:
        --------
        zmax : float
            Sea surface elevation.
        """
        cdef DTYPE_FLOAT_t time_fraction # Time interpolation coefficient
        cdef DTYPE_FLOAT_t zeta # Sea surface elevation at (t, x1, x2)

        time_fraction = interp.get_linear_fraction_safe(time, self._time_last, self._time_next)

        zeta = self._unstructured_grid.interpolate_in_time_and_space_2D(self._zeta_last,
                                                                        self._zeta_next,
                                                                        time_fraction,
                                                                        particle)

        return zeta

    cdef void get_velocity(self, DTYPE_FLOAT_t time, Particle* particle,
            DTYPE_FLOAT_t vel[3]) except +:
        """ Returns the velocity u(t,x,y,z) through linear interpolation
        
        Returns the velocity u(t,x,y,z) through interpolation for a particle.

        Parameters:
        -----------
        time : float
            Time at which to interpolate.
        
        particle: *Particle
            Pointer to a Particle object.

        Return:
        -------
        vel : C array, float
            u/v/w velocity components stored in a C array.           
        """
        # Compute u/v velocities and save
        self._get_velocity_using_shepard_interpolation(time, particle, vel)
        return

    cdef DTYPE_FLOAT_t get_environmental_variable(self, var_name,
            DTYPE_FLOAT_t time, Particle *particle) except FLOAT_ERR:
        """ Returns the value of the given environmental variable through linear interpolation

        In FVCOM, active and passive tracers are defined at element nodes on sigma layers,
        which is the same as viscofh. Above and below the top and bottom sigma layers respectively
        values for the specified variable are extrapolated, taking a value equal to that at the layer
        centre. Linear interpolation in the vertical is used for z positions lying between the top
        and bottom sigma layers.

        NB - All the hard work is farmed out to a private function, which both this function and the
        function for computing viscofh use.

        Support for extracting the following FVCOM environmental variables has been implemented:

        thetao - Sea water potential temperature

        so - Sea water salinty

        Parameters:
        -----------
        var_name : str
            The name of the variable. See above for a list of supported options.

        time : float
            Time at which to interpolate.

        particle: *Particle
            Pointer to a Particle object.

        Returns:
        --------
        var : float
            The interpolated value of the variable at the specified point in time and space.
        """
        cdef DTYPE_FLOAT_t var # Environmental variable at (t, x1, x2, x3)

        if var_name in self.env_var_names:
            if var_name == 'thetao':
                var = self._get_variable(self._thetao_last, self._thetao_next, time, particle)
            elif var_name == 'so':
                var = self._get_variable(self._so_last, self._so_next, time, particle)
            return var
        else:
            raise ValueError("Invalid variable name `{}'".format(var_name))

    cdef DTYPE_FLOAT_t get_horizontal_eddy_diffusivity(self, DTYPE_FLOAT_t time,
            Particle* particle) except FLOAT_ERR:
        """ Returns the horizontal eddy diffusivity through linear interpolation

        viscofh is defined at element nodes on sigma layers. Above and below the
        top and bottom sigma layers respectively viscofh is extrapolated, taking
        a value equal to that at the layer centre. Linear interpolation in the vertical
        is used for z positions lying between the top and bottom sigma layers.

        This function is effectively a wrapper for the private method `_get_variable'.

        Parameters:
        -----------
        time : float
            Time at which to interpolate.

        particle: *Particle
            Pointer to a Particle object.

        Returns:
        --------
        viscofh : float
            The interpolated value of the horizontal eddy diffusivity at the specified point in time and space.
        """
        cdef DTYPE_FLOAT_t var # viscofh at (t, x1, x2, x3)

        if self._Ah_method == 1:
            var = self._get_variable(self._viscofh_last, self._viscofh_next, time, particle)
        else:
            raise RuntimeError("Trying to access horizontal eddy diffusivities, but `Ah_method = none`. "\
                               "If horizontal eddy diffusivities have been saved by FVCOM and you wish "\
                               "to run with diffusive mixing in the horizontal, try setting `Ah_method = file` "\
                               "in the run configuration file.")

        return var

    cdef void get_horizontal_eddy_diffusivity_derivative(self, DTYPE_FLOAT_t time,
            Particle* particle, DTYPE_FLOAT_t Ah_prime[2]) except +:
        """ Returns the gradient in the horizontal eddy diffusivity
        
        The gradient is first computed on sigma layers bounding the particle's
        position, or simply on the nearest layer if the particle lies above or
        below the top or bottom sigma layers respectively. Linear interpolation
        in the vertical is used for z positions lying between the top and bottom
        sigma layers.
        
        Within an element, the gradient itself is calculated from the gradient 
        in the element's barycentric coordinates `phi' through linear
        interpolation (e.g. Lynch et al 2015, p. 238) 
        
        Parameters:
        -----------
        time : float
            Time at which to interpolate.
        
        particle: *Particle
            Pointer to a Particle object.

        Ah_prime : C array, float
            dAh_dx and dH_dy components stored in a C array of length two.  

        References:
        -----------
        Lynch, D. R. et al (2014). Particles in the coastal ocean: theory and
        applications. Cambridge: Cambridge University Press.
        doi.org/10.1017/CBO9781107449336
        """
        # Variable used in interpolation in time
        cdef DTYPE_FLOAT_t time_fraction

        # Particle k_layers
        cdef DTYPE_INT_t k_layer = particle.get_k_layer()
        cdef DTYPE_INT_t k_lower_layer = particle.get_k_lower_layer()
        cdef DTYPE_INT_t k_upper_layer = particle.get_k_upper_layer()

        # Ah on upper and lower layers
        cdef DTYPE_FLOAT_t Ah_prime_lower_layer[2]
        cdef DTYPE_FLOAT_t Ah_prime_upper_layer[2]

        # Loop counter
        cdef int i

        if self._Ah_method == 1:
            # Time fraction
            time_fraction = interp.get_linear_fraction_safe(time, self._time_last, self._time_next)

            # No vertical interpolation for particles near to the surface or bottom,
            # i.e. above or below the top or bottom sigma layer depths respectively.
            if (particle.get_in_surface_boundary_layer() is True or particle.get_in_bottom_boundary_layer() is True):
                self._unstructured_grid.interpolate_grad_in_time_and_space(self._viscofh_last, self._viscofh_next,
                                                                           k_layer, time_fraction, particle,
                                                                           Ah_prime)
                return

            # Interpolate between layers
            self._unstructured_grid.interpolate_grad_in_time_and_space(self._viscofh_last, self._viscofh_next,
                                                               k_lower_layer, time_fraction, particle,
                                                               Ah_prime_lower_layer)

            self._unstructured_grid.interpolate_grad_in_time_and_space(self._viscofh_last, self._viscofh_next,
                                                               k_upper_layer, time_fraction, particle,
                                                               Ah_prime_upper_layer)

            # Interpolate d{}/dx and d{}/dy between bounding sigma layers and
            # save in the array Ah_prime
            for i in range(2):
                Ah_prime[i] = interp.linear_interp(particle.get_omega_layers(), Ah_prime_lower_layer[i], Ah_prime_upper_layer[i])

            return

        else:
            raise RuntimeError("Trying to access horizontal eddy diffusivities, but `Ah_method = none`. "\
                               "If horizontal eddy diffusivities have been saved by FVCOM and you wish "\
                               "to run with diffusive mixing in the horizontal, try setting `Ah_method = file` "\
                               "in the run configuration file.")

    cdef DTYPE_FLOAT_t get_vertical_eddy_diffusivity(self, DTYPE_FLOAT_t time,
            Particle* particle) except FLOAT_ERR:
        """ Returns the vertical eddy diffusivity through linear interpolation.
        
        The vertical eddy diffusivity is defined at element nodes on sigma
        levels. Interpolation is performed first in time, then in x and y,
        and finally in z.
        
        Parameters:
        -----------
        time : float
            Time at which to interpolate.
        
        particle: *Particle
            Pointer to a Particle object.
        
        Returns:
        --------
        Kz : float
            The vertical eddy diffusivity.        
        
        """
        # Particle k_layer
        cdef DTYPE_INT_t k_layer = particle.get_k_layer()

        # Time fraction
        cdef DTYPE_FLOAT_t time_fraction

        # Interpolated diffusivities on lower and upper bounding sigma levels
        cdef DTYPE_FLOAT_t Kz_lower_level
        cdef DTYPE_FLOAT_t Kz_upper_level

        # Variable
        cdef DTYPE_FLOAT_t Kz

        if self._Kz_method == 1:
            # Time fraction
            time_fraction = interp.get_linear_fraction_safe(time, self._time_last, self._time_next)

            # NB The index corresponding to the layer the particle presently resides
            # in is used to calculate the index of the under and over lying k levels
            Kz_lower_level = self._unstructured_grid.interpolate_in_time_and_space(self._Kz_last,
                                                                                   self._Kz_next,
                                                                                   k_layer+1,
                                                                                   time_fraction,
                                                                                   particle)
            Kz_upper_level = self._unstructured_grid.interpolate_in_time_and_space(self._Kz_last,
                                                                                   self._Kz_next,
                                                                                   k_layer,
                                                                                   time_fraction,
                                                                                   particle)
            Kz = interp.linear_interp(particle.get_omega_interfaces(), Kz_lower_level, Kz_upper_level)

        else:
            raise RuntimeError("Trying to access vertical eddy diffusivities, but `Kz_method = none`. "\
                               "If vertical eddy diffusivities have been saved by FVCOM and you wish "\
                               "to run with diffusive mixing in the vertical, try setting `Kz_method = file` "\
                               "in the run configuration file.")

        return Kz

    cdef DTYPE_FLOAT_t get_vertical_eddy_diffusivity_derivative(self,
            DTYPE_FLOAT_t time, Particle* particle) except FLOAT_ERR:
        """ Returns the gradient in the vertical eddy diffusivity.
        
        Return a numerical approximation of the gradient in the vertical eddy 
        diffusivity at (t,x,y,z) using central differencing. First, the
        diffusivity is computed on the sigma levels bounding the particle.
        Central differencing is then used to compute the gradient in the
        diffusivity on these levels. Finally, the gradient in the diffusivity
        is interpolated to the particle's exact position. This algorithm
        mirrors that used in GOTMDataReader, which is why it has been implemented
        here. However, in contrast to GOTMDataReader, which calculates the
        gradient in the diffusivity at all levels once each simulation time step,
        resulting in significant time savings, this function is exectued once
        for each particle. It is thus quite costly! To make things worse, the 
        code, as implemented here, is highly repetitive, and no doubt efficiency
        savings could be found. 

        Parameters:
        -----------
        time : float
            Time at which to interpolate.
        
        particle: *Particle
            Pointer to a Particle object.
        
        Returns:
        --------
        k_prime : float
            Gradient in the vertical eddy diffusivity field.
        """
        cdef DTYPE_FLOAT_t Kz_0, Kz_1, Kz_2, Kz_3
        cdef DTYPE_FLOAT_t z_0, z_1, z_2, z_3
        cdef DTYPE_FLOAT_t dKz_lower_level, dKz_upper_level

        # Time fraction
        cdef DTYPE_FLOAT_t time_fraction

        # Particle k_layer
        cdef DTYPE_INT_t k_layer

        # dKz_dz
        cdef DTYPE_FLOAT_t dKz_dz

        if self._Kz_method == 1:
            # Pre-compute k_layer, time fraction
            k_layer = particle.get_k_layer()
            time_fraction = interp.get_linear_fraction_safe(time, self._time_last, self._time_next)

            if k_layer == 0:
                Kz_0 = self._unstructured_grid.interpolate_in_time_and_space(self._Kz_last,
                                                                             self._Kz_next,
                                                                             k_layer,
                                                                             time_fraction,
                                                                             particle)
                z_0 = self._unstructured_grid.interpolate_in_time_and_space(self._depth_levels_last,
                                                                            self._depth_levels_next,
                                                                            k_layer,
                                                                            time_fraction,
                                                                            particle)

                Kz_1 = self._unstructured_grid.interpolate_in_time_and_space(self._Kz_last,
                                                                             self._Kz_next,
                                                                             k_layer+1,
                                                                             time_fraction,
                                                                             particle)
                z_1 = self._unstructured_grid.interpolate_in_time_and_space(self._depth_levels_last,
                                                                            self._depth_levels_next,
                                                                            k_layer+1,
                                                                            time_fraction,
                                                                            particle)

                Kz_2 = self._unstructured_grid.interpolate_in_time_and_space(self._Kz_last,
                                                                             self._Kz_next,
                                                                             k_layer+2,
                                                                             time_fraction,
                                                                             particle)
                z_2 = self._unstructured_grid.interpolate_in_time_and_space(self._depth_levels_last,
                                                                            self._depth_levels_next,
                                                                            k_layer+2,
                                                                            time_fraction,
                                                                            particle)

                dKz_lower_level = (Kz_0 - Kz_2) / (z_0 - z_2)
                dKz_upper_level = (Kz_0 - Kz_1) / (z_0 - z_1)

            elif k_layer == self._n_siglay - 1:
                Kz_0 = self._unstructured_grid.interpolate_in_time_and_space(self._Kz_last,
                                                                             self._Kz_next,
                                                                             k_layer-1,
                                                                             time_fraction,
                                                                             particle)
                z_0 = self._unstructured_grid.interpolate_in_time_and_space(self._depth_levels_last,
                                                                            self._depth_levels_next,
                                                                            k_layer-1,
                                                                            time_fraction,
                                                                            particle)

                Kz_1 = self._unstructured_grid.interpolate_in_time_and_space(self._Kz_last,
                                                                             self._Kz_next,
                                                                             k_layer,
                                                                             time_fraction,
                                                                             particle)
                z_1 = self._unstructured_grid.interpolate_in_time_and_space(self._depth_levels_last,
                                                                            self._depth_levels_next,
                                                                            k_layer,
                                                                            time_fraction,
                                                                            particle)

                Kz_2 = self._unstructured_grid.interpolate_in_time_and_space(self._Kz_last,
                                                                             self._Kz_next,
                                                                             k_layer+1,
                                                                             time_fraction,
                                                                             particle)
                z_2 = self._unstructured_grid.interpolate_in_time_and_space(self._depth_levels_last,
                                                                            self._depth_levels_next,
                                                                            k_layer+1,
                                                                            time_fraction,
                                                                            particle)

                dKz_lower_level = (Kz_1 - Kz_2) / (z_1 - z_2)
                dKz_upper_level = (Kz_0 - Kz_2) / (z_0 - z_2)

            else:
                Kz_0 = self._unstructured_grid.interpolate_in_time_and_space(self._Kz_last,
                                                                             self._Kz_next,
                                                                             k_layer-1,
                                                                             time_fraction,
                                                                             particle)
                z_0 = self._unstructured_grid.interpolate_in_time_and_space(self._depth_levels_last,
                                                                            self._depth_levels_next,
                                                                            k_layer-1,
                                                                            time_fraction,
                                                                            particle)

                Kz_1 = self._unstructured_grid.interpolate_in_time_and_space(self._Kz_last,
                                                                             self._Kz_next,
                                                                             k_layer,
                                                                             time_fraction,
                                                                             particle)
                z_1 = self._unstructured_grid.interpolate_in_time_and_space(self._depth_levels_last,
                                                                            self._depth_levels_next,
                                                                            k_layer,
                                                                            time_fraction,
                                                                            particle)

                Kz_2 = self._unstructured_grid.interpolate_in_time_and_space(self._Kz_last,
                                                                             self._Kz_next,
                                                                             k_layer+1,
                                                                             time_fraction,
                                                                             particle)
                z_2 = self._unstructured_grid.interpolate_in_time_and_space(self._depth_levels_last,
                                                                            self._depth_levels_next,
                                                                            k_layer+1,
                                                                            time_fraction,
                                                                            particle)

                Kz_3 = self._unstructured_grid.interpolate_in_time_and_space(self._Kz_last,
                                                                             self._Kz_next,
                                                                             k_layer+2,
                                                                             time_fraction,
                                                                             particle)
                z_3 = self._unstructured_grid.interpolate_in_time_and_space(self._depth_levels_last,
                                                                            self._depth_levels_next,
                                                                            k_layer+2,
                                                                            time_fraction,
                                                                            particle)

                dKz_lower_level = (Kz_1 - Kz_3) / (z_1 - z_3)
                dKz_upper_level = (Kz_0 - Kz_2) / (z_0 - z_2)

            dKz_dz = interp.linear_interp(particle.get_omega_interfaces(), dKz_lower_level, dKz_upper_level)

        else:
            raise RuntimeError("Trying to access vertical eddy diffusivities, but `Kz_method = none`. "\
                               "If vertical eddy diffusivities have been saved by FVCOM and you wish "\
                               "to run with diffusive mixing in the vertical, try setting `Kz_method = file` "\
                               "in the run configuration file.")

        return dKz_dz

    cdef DTYPE_INT_t is_wet(self, DTYPE_FLOAT_t time, Particle *particle) except INT_ERR:
        """ Return an integer indicating whether `host' is wet or dry
        
        The function returns 1 if `host' is wet at time `time' and 
        0 if `host' is dry.
        
        The wet-dry distinction reflects two discrete states - either the
        element is wet, or it is dry. This raises the question of how to deal
        with intermediate times, such that td < t < tw where
        t is the current model time, and td and tw are conescutive input time
        points between which the host element switches from being dry to being
        wet. The approach taken is conservative, and involves flagging the
        element as being dry if either one or both of the input time points
        bounding the current model time indicate that the element is dry. In this
        simple procedure, the `time' parameter is actually unused.
        
        NB - just because an element is flagged as being dry does not mean
        that particles are necessarily frozen. Clients can still try to advect
        particles within such elements, and the interpolated velocity field may
        yield non-zero values, depending on the state of the host and
        surrounding elements in the given time window.
        
        Parameters:
        -----------
        time : float
            Time (unused)

        host : int
            Integer that identifies the host element in question
        """
        cdef DTYPE_INT_t host_element = particle.get_host_horizontal_elem(self._name)

        if self._has_is_wet:
            if self._wet_cells_last[host_element] == 0 or self._wet_cells_next[host_element] == 0:
                return 0
        return 1
        
    cdef DTYPE_FLOAT_t _get_variable(self, DTYPE_FLOAT_t[:, ::1] var_last, DTYPE_FLOAT_t[:, ::1] var_next,
            DTYPE_FLOAT_t time, Particle* particle) except FLOAT_ERR:
        """ Returns the value of the variable through linear interpolation

        Private method for interpolating fields specified at element nodes on sigma layers.
        This is the case for both viscofh and active and passive tracers. Above and below the
        top and bottom sigma layers respectively values are extrapolated, taking
        a value equal to that at the layer centre. Linear interpolation in the vertical
        is used for z positions lying between the top and bottom sigma layers.
        
        Parameters:
        -----------
        var_last : 2D MemoryView
            Array of variable values at the last time index.

        var_next : 2D MemoryView
            Array of variable values at the next time index.

        time : float
            Time at which to interpolate.
        
        particle: *Particle
            Pointer to a Particle object. 
        
        Returns:
        --------
        var : float
            The interpolated value of the variable at the specified point in time and space.
        """
        # Variables used in interpolation in time
        cdef DTYPE_FLOAT_t time_fraction
        
        # Interpolated values on lower and upper bounding sigma layers
        cdef DTYPE_FLOAT_t var_layer_1
        cdef DTYPE_FLOAT_t var_layer_2

        # Particle k layers
        cdef DTYPE_INT_t k_layer = particle.get_k_layer()
        cdef DTYPE_INT_t k_lower_layer = particle.get_k_lower_layer()
        cdef DTYPE_INT_t k_upper_layer = particle.get_k_upper_layer()

        # Time fraction
        time_fraction = interp.get_linear_fraction_safe(time, self._time_last, self._time_next)

        # No vertical interpolation for particles near to the surface or bottom, 
        # i.e. above or below the top or bottom sigma layer depths respectively.
        if (particle.get_in_surface_boundary_layer() is True or particle.get_in_bottom_boundary_layer() is True):
            return self._unstructured_grid.interpolate_in_time_and_space(var_last,
                                                                         var_next,
                                                                         k_layer,
                                                                         time_fraction,
                                                                         particle)

        else:
            var_layer_1 = self._unstructured_grid.interpolate_in_time_and_space(var_last,
                                                                                var_next,
                                                                                k_lower_layer,
                                                                                time_fraction,
                                                                                particle)

            var_layer_2 = self._unstructured_grid.interpolate_in_time_and_space(var_last,
                                                                                var_next,
                                                                                k_upper_layer,
                                                                                time_fraction,
                                                                                particle)

            return interp.linear_interp(particle.get_omega_interfaces(), var_layer_1, var_layer_2)

    cdef void _get_velocity_using_shepard_interpolation(self, DTYPE_FLOAT_t time,
            Particle* particle, DTYPE_FLOAT_t vel[3]) except +:
        """ Return (u,v,w) velocities at a point using Shepard interpolation
        
        In FVCOM, the u, v, and w velocity components are defined at element
        centres on sigma layers and saved at discrete points in time. Here,
        u(t,x,y,z), v(t,x,y,z) and w(t,x,y,z) are retrieved through i) linear
        interpolation in t and z, and ii) Shepard interpolation (a special
        case of normalized radial basis function interpolation) in x and y.

        In Shepard interpolation, the algorithm uses velocities defined at 
        the host element's centre and its immediate neghbours (i.e. at the
        centre of those elements that share a face with the host element).

        If the particle is in the bottom boundary layer - meaning it lies
        above the sea bed but below the bottom sigma layer - the velocity
        can be corrected using a logarithmic profile. This option is enabled
        using the run time configuration parameters
        `correct_near_bottom_velocities' and `z0' (the roughness length
        scale). If `correct_near_bottom_velocities' is set to False, the
        velocity at the bottom sigma layer is extrapolated to the particle's
        position.
        
        When applying the log correction, the velocity is given by:

        u(z_p) = u(z_1) ln(z_p/z0) / ln(z_1/z0)

        where u(z_p) is the velocity at the particle's position, u(z_1) is the
        velocity at the bottom sigma layer, z_p is the height of the particle
        above the sea bed, z_1 is the height of the bottom sigma layer above the
        sea bed, and z0 is the roughness length scale.

        NB - this function returns the vertical velocity in z coordinate space
        (units m/s) and not the vertical velocity in sigma coordinate space.
        
        Parameters:
        -----------
        time : float
            Time at which to interpolate.
        
        particle: *Particle
            Pointer to a Particle object.
        
        Returns:
        --------
        vel : C array, float
            Three element array giving the u, v and w velocity components.
        """
        # x/y coordinates of element centres
        cdef DTYPE_FLOAT_t xc[4]
        cdef DTYPE_FLOAT_t yc[4]

        # Vel at element centres in overlying sigma layer
        cdef DTYPE_FLOAT_t uc1[4]
        cdef DTYPE_FLOAT_t vc1[4]
        cdef DTYPE_FLOAT_t wc1[4]

        # Vel at element centres in underlying sigma layer
        cdef DTYPE_FLOAT_t uc2[4]
        cdef DTYPE_FLOAT_t vc2[4]
        cdef DTYPE_FLOAT_t wc2[4]

        # Flag for valid points
        cdef DTYPE_INT_t valid_points[4]
        
        # Particle k layers
        cdef DTYPE_INT_t k_layer = particle.get_k_layer()
        cdef DTYPE_INT_t k_lower_layer = particle.get_k_lower_layer()
        cdef DTYPE_INT_t k_upper_layer = particle.get_k_upper_layer()
        cdef DTYPE_INT_t host_element = particle.get_host_horizontal_elem(self._name)

        # Vel at the given location in the overlying sigma layer
        cdef DTYPE_FLOAT_t up1, vp1, wp1
        
        # Vel at the given location in the underlying sigma layer
        cdef DTYPE_FLOAT_t up2, vp2, wp2
         
        # Variables used in interpolation in time      
        cdef DTYPE_FLOAT_t time_fraction

        # Variables used in log profile correction
        cdef DTYPE_FLOAT_t z_min, z_layer
        cdef DTYPE_FLOAT_t A1, A2

        # Array and loop indices
        cdef int i, j, neighbour
        
        # Time fraction
        time_fraction = interp.get_linear_fraction_safe(time, self._time_last, self._time_next)

        if (particle.get_in_surface_boundary_layer() is True or particle.get_in_bottom_boundary_layer() is True):
            # These two situations may be handled differently. This comes later. For now, we interpolate velocity components
            # in the nearest sigma layer.
            xc[0] = self._xc[host_element]
            yc[0] = self._yc[host_element]
            uc1[0] = interp.linear_interp(time_fraction, self._u_last[k_layer, host_element], self._u_next[k_layer, host_element])
            vc1[0] = interp.linear_interp(time_fraction, self._v_last[k_layer, host_element], self._v_next[k_layer, host_element])
            wc1[0] = interp.linear_interp(time_fraction, self._w_last[k_layer, host_element], self._w_next[k_layer, host_element])
            valid_points[0] = 1
            for i in xrange(3):
                neighbour = self._nbe[i, host_element]
                j = i + 1
                if neighbour >= 0:
                    xc[j] = self._xc[neighbour]
                    yc[j] = self._yc[neighbour]
                    uc1[j] = interp.linear_interp(time_fraction, self._u_last[k_layer, neighbour], self._u_next[k_layer, neighbour])
                    vc1[j] = interp.linear_interp(time_fraction, self._v_last[k_layer, neighbour], self._v_next[k_layer, neighbour])
                    wc1[j] = interp.linear_interp(time_fraction, self._w_last[k_layer, neighbour], self._w_next[k_layer, neighbour])
                    valid_points[j] = 1
                else:
                    # Set all values to zero and flag as an invalid point so that it is not used in the interpolation
                    xc[j] = 0.0
                    yc[j] = 0.0
                    uc1[j] = 0.0
                    vc1[j] = 0.0
                    wc1[j] = 0.0
                    valid_points[j] = 0

            up1 = self._unstructured_grid.shepard_interpolation(particle.get_x1(), particle.get_x2(), xc, yc, uc1, valid_points)
            vp1 = self._unstructured_grid.shepard_interpolation(particle.get_x1(), particle.get_x2(), xc, yc, vc1, valid_points)
            wp1 = self._unstructured_grid.shepard_interpolation(particle.get_x1(), particle.get_x2(), xc, yc, wc1, valid_points)

            if particle.get_in_surface_boundary_layer() is True:
                # TODO - Include options here to correct near surface velocities?
                vel[0] = up1
                vel[1] = vp1
                vel[2] = wp1
                return

            elif particle.get_in_bottom_boundary_layer() is True:
                if self._correct_near_bottom_velocities:
                    # Use the logarithmic profile to correct the near bottom velocity
                    # ---------------------------------------------------------------

                    # Determine the sea floor depth at the particle's position
                    z_min = self.get_zmin(time, particle)

                    # Compute the depth of the bottom sigma layer at the particle's position
                    z_layer = self._unstructured_grid.interpolate_in_time_and_space(self._depth_layers_last,
                                                                                    self._depth_layers_next,
                                                                                    particle.get_k_layer(),
                                                                                    time_fraction,
                                                                                    particle)

                    # Precalculate logarithmic terms
                    if particle.get_x3() > (z_min + self._z0):
                        A1 = log((z_layer - z_min) / self._z0)
                        A2 = log((particle.get_x3() - z_min) / self._z0)

                        # Apply correction
                        vel[0] = up1 * A2 / A1
                        vel[1] = vp1 * A2 / A1
                        vel[2] = wp1 * A2 / A1
                    else:
                        vel[0] = 0.0
                        vel[1] = 0.0
                        vel[2] = 0.0

                else:
                    # Simply extrapolate downwards
                    # ----------------------------
                    vel[0] = up1
                    vel[1] = vp1
                    vel[2] = wp1

                return 
            
            else:
                raise PyLagRuntimeError("Check above if logic - it should be impossible to reach this point.")

        # Interpolate between depth levels
        xc[0] = self._xc[host_element]
        yc[0] = self._yc[host_element]
        uc1[0] = interp.linear_interp(time_fraction, self._u_last[k_lower_layer, host_element], self._u_next[k_lower_layer, host_element])
        vc1[0] = interp.linear_interp(time_fraction, self._v_last[k_lower_layer, host_element], self._v_next[k_lower_layer, host_element])
        wc1[0] = interp.linear_interp(time_fraction, self._w_last[k_lower_layer, host_element], self._w_next[k_lower_layer, host_element])
        uc2[0] = interp.linear_interp(time_fraction, self._u_last[k_upper_layer, host_element], self._u_next[k_upper_layer, host_element])
        vc2[0] = interp.linear_interp(time_fraction, self._v_last[k_upper_layer, host_element], self._v_next[k_upper_layer, host_element])
        wc2[0] = interp.linear_interp(time_fraction, self._w_last[k_upper_layer, host_element], self._w_next[k_upper_layer, host_element])
        valid_points[0] = 1
        for i in xrange(3):
            neighbour = self._nbe[i, host_element]
            j = i + 1
            if neighbour >= 0:
                xc[j] = self._xc[neighbour]
                yc[j] = self._yc[neighbour]
                uc1[j] = interp.linear_interp(time_fraction, self._u_last[k_lower_layer, neighbour], self._u_next[k_lower_layer, neighbour])
                vc1[j] = interp.linear_interp(time_fraction, self._v_last[k_lower_layer, neighbour], self._v_next[k_lower_layer, neighbour])
                wc1[j] = interp.linear_interp(time_fraction, self._w_last[k_lower_layer, neighbour], self._w_next[k_lower_layer, neighbour])
                uc2[j] = interp.linear_interp(time_fraction, self._u_last[k_upper_layer, neighbour], self._u_next[k_upper_layer, neighbour])
                vc2[j] = interp.linear_interp(time_fraction, self._v_last[k_upper_layer, neighbour], self._v_next[k_upper_layer, neighbour])
                wc2[j] = interp.linear_interp(time_fraction, self._w_last[k_upper_layer, neighbour], self._w_next[k_upper_layer, neighbour])
                valid_points[j] = 1
            else:
                xc[j] = 0.0
                yc[j] = 0.0
                uc1[j] = 0.0
                vc1[j] = 0.0
                wc1[j] = 0.0
                uc2[j] = 0.0
                vc2[j] = 0.0
                wc2[j] = 0.0
                valid_points[j] = 0

        # ... lower bounding sigma layer
        up1 = self._unstructured_grid.shepard_interpolation(particle.get_x1(), particle.get_x2(), xc, yc, uc1, valid_points)
        vp1 = self._unstructured_grid.shepard_interpolation(particle.get_x1(), particle.get_x2(), xc, yc, vc1, valid_points)
        wp1 = self._unstructured_grid.shepard_interpolation(particle.get_x1(), particle.get_x2(), xc, yc, wc1, valid_points)

        # ... upper bounding sigma layer
        up2 = self._unstructured_grid.shepard_interpolation(particle.get_x1(), particle.get_x2(), xc, yc, uc2, valid_points)
        vp2 = self._unstructured_grid.shepard_interpolation(particle.get_x1(), particle.get_x2(), xc, yc, vc2, valid_points)
        wp2 = self._unstructured_grid.shepard_interpolation(particle.get_x1(), particle.get_x2(), xc, yc, wc2, valid_points)

        # Vertical interpolation
        vel[0] = interp.linear_interp(particle.get_omega_layers(), up1, up2)
        vel[1] = interp.linear_interp(particle.get_omega_layers(), vp1, vp2)
        vel[2] = interp.linear_interp(particle.get_omega_layers(), wp1, wp2)
        return

    def _read_grid(self):
        """ Set grid and coordinate variables.
        
        All communications go via the mediator in order to guarantee support for
        both serial and parallel simulations.
        
        Parameters:
        -----------
        N/A
        
        Returns:
        --------
        N/A
        """
        # Read in the grid's dimensions
        self._n_nodes = self.mediator.get_dimension_variable('node')
        self._n_elems = self.mediator.get_dimension_variable('element')
        self._n_siglev = self.mediator.get_dimension_variable('siglev')
        self._n_siglay = self.mediator.get_dimension_variable('siglay')
        
        # Grid connectivity/adjacency
        self._nv = self.mediator.get_grid_variable('nv', (3, self._n_elems), DTYPE_INT)
        self._nbe = self.mediator.get_grid_variable('nbe', (3, self._n_elems), DTYPE_INT)

        # Raw grid x/y or lat/lon coordinates
        if self._coordinate_system == cartesian:
            x = self.mediator.get_grid_variable('x', (self._n_nodes), DTYPE_FLOAT)
            y = self.mediator.get_grid_variable('y', (self._n_nodes), DTYPE_FLOAT)
            xc = self.mediator.get_grid_variable('xc', (self._n_elems), DTYPE_FLOAT)
            yc = self.mediator.get_grid_variable('yc', (self._n_elems), DTYPE_FLOAT)

            # calculate offsets
            self._xmin = np.min(x)
            self._ymin = np.min(y)

            # Apply offsets
            self._x = x - self._xmin
            self._y = y - self._ymin
            self._xc = xc - self._xmin
            self._yc = yc - self._ymin

        elif self._coordinate_system == geographic:
            x = self.mediator.get_grid_variable('longitude', (self._n_nodes), DTYPE_FLOAT)
            y = self.mediator.get_grid_variable('latitude', (self._n_nodes), DTYPE_FLOAT)
            xc = self.mediator.get_grid_variable('longitude_c', (self._n_elems), DTYPE_FLOAT)
            yc = self.mediator.get_grid_variable('latitude_c', (self._n_elems), DTYPE_FLOAT)

            # Convert to radians
            self._x = x * deg_to_radians
            self._y = y * deg_to_radians
            self._xc = xc * deg_to_radians
            self._yc = yc * deg_to_radians

            # Don't apply offsets in geographic case - set them to 0.0!
            self._xmin = 0.0
            self._ymin = 0.0

        # Land sea mask
        self._land_sea_mask_c = self.mediator.get_grid_variable('mask_c', (self._n_elems), DTYPE_INT)
        self._land_sea_mask = np.zeros(self._n_nodes, dtype=DTYPE_INT)

        # Initialise unstructured grid
        self._unstructured_grid = get_unstructured_grid(self.config, self._name, self._n_nodes, self._n_elems, self._nv,
                                                        self._nbe, self._x, self._y, self._xc, self._yc,
                                                        self._land_sea_mask_c, self._land_sea_mask)

        # Sigma levels at nodal coordinates
        self._siglev = self.mediator.get_grid_variable('siglev', (self._n_siglev, self._n_nodes), DTYPE_FLOAT)

        # Sigma layers at nodal coordinates
        self._siglay = self.mediator.get_grid_variable('siglay', (self._n_siglay, self._n_nodes), DTYPE_FLOAT)

        # Bathymetry
        self._h = self.mediator.get_grid_variable('h', (self._n_nodes), DTYPE_FLOAT)

    cdef _read_time_dependent_vars(self):
        """ Update time variables and memory views for FVCOM data fields.
        
        For each FVCOM time-dependent variable needed by PyLag two references
        are stored. These correspond to the last and next time points at which
        FVCOM data was saved. Together these bound PyLag's current time point.
        
        All communications go via the mediator in order to guarantee support for
        both serial and parallel simulations.
        
        Parameters:
        -----------
        N/A
        
        Returns:
        --------
        N/A
        """
        # Update time references
        self._time_last = self.mediator.get_time_at_last_time_index()
        self._time_next = self.mediator.get_time_at_next_time_index()
        
        # Update memory views for zeta
        self._zeta_last = self.mediator.get_time_dependent_variable_at_last_time_index('zeta', (self._n_nodes), DTYPE_FLOAT)
        self._zeta_next = self.mediator.get_time_dependent_variable_at_next_time_index('zeta', (self._n_nodes), DTYPE_FLOAT)

        # Update memory views for sigma layer and level depths. These are computed using sigma, h and zeta.
        self._depth_levels_last = sigma_to_z(self._siglev, self._h, self._zeta_last)
        self._depth_levels_next = sigma_to_z(self._siglev, self._h, self._zeta_next)
        self._depth_layers_last = sigma_to_z(self._siglay, self._h, self._zeta_last)
        self._depth_layers_next = sigma_to_z(self._siglay, self._h, self._zeta_next)

        # Update memory views for u, v and w
        self._u_last = self.mediator.get_time_dependent_variable_at_last_time_index('u', (self._n_siglay, self._n_elems), DTYPE_FLOAT)
        self._u_next = self.mediator.get_time_dependent_variable_at_next_time_index('u', (self._n_siglay, self._n_elems), DTYPE_FLOAT)
        self._v_last = self.mediator.get_time_dependent_variable_at_last_time_index('v', (self._n_siglay, self._n_elems), DTYPE_FLOAT)
        self._v_next = self.mediator.get_time_dependent_variable_at_next_time_index('v', (self._n_siglay, self._n_elems), DTYPE_FLOAT)
        self._w_last = self.mediator.get_time_dependent_variable_at_last_time_index('ww', (self._n_siglay, self._n_elems), DTYPE_FLOAT)
        self._w_next = self.mediator.get_time_dependent_variable_at_next_time_index('ww', (self._n_siglay, self._n_elems), DTYPE_FLOAT)
        
        # Update memory views for Kz
        if self._Kz_method == 1:
            self._Kz_last = self.mediator.get_time_dependent_variable_at_last_time_index('kh', (self._n_siglev, self._n_nodes), DTYPE_FLOAT)
            self._Kz_next = self.mediator.get_time_dependent_variable_at_next_time_index('kh', (self._n_siglev, self._n_nodes), DTYPE_FLOAT)

        # Update memory views for viscofh
        if self._Ah_method == 1:
            self._viscofh_last = self.mediator.get_time_dependent_variable_at_last_time_index('viscofh', (self._n_siglay, self._n_nodes), DTYPE_FLOAT)
            self._viscofh_next = self.mediator.get_time_dependent_variable_at_next_time_index('viscofh', (self._n_siglay, self._n_nodes), DTYPE_FLOAT)

        # Update memory views for wet cells
        if self._has_is_wet:
            self._wet_cells_last = self.mediator.get_time_dependent_variable_at_last_time_index('wet_cells', (self._n_elems), DTYPE_INT)
            self._wet_cells_next = self.mediator.get_time_dependent_variable_at_next_time_index('wet_cells', (self._n_elems), DTYPE_INT)

        # Read in data as requested
        if 'thetao' in self.env_var_names:
            fvcom_var_name = variable_library.fvcom_variable_names['thetao']
            self._thetao_last = self.mediator.get_time_dependent_variable_at_last_time_index(fvcom_var_name, (self._n_siglay, self._n_nodes), DTYPE_FLOAT)
            self._thetao_next = self.mediator.get_time_dependent_variable_at_next_time_index(fvcom_var_name, (self._n_siglay, self._n_nodes), DTYPE_FLOAT)

        if 'so' in self.env_var_names:
            fvcom_var_name = variable_library.fvcom_variable_names['so']
            self._so_last = self.mediator.get_time_dependent_variable_at_last_time_index(fvcom_var_name, (self._n_siglay, self._n_nodes), DTYPE_FLOAT)
            self._so_next = self.mediator.get_time_dependent_variable_at_next_time_index(fvcom_var_name, (self._n_siglay, self._n_nodes), DTYPE_FLOAT)

        return


cpdef sigma_to_z(const DTYPE_FLOAT_t[:, ::1] sigma, const DTYPE_FLOAT_t[::1] h, const DTYPE_FLOAT_t[::1] zeta):
    cdef DTYPE_FLOAT_t[:, ::1] z_view

    cdef size_t n, m
    cdef size_t i, j

    n = sigma.shape[0]
    m = sigma.shape[1]

    if h.shape[0] != m or zeta.shape[0] != m:
        raise ValueError('Array sizes do not match')

    z = np.empty((n, m), dtype=DTYPE_FLOAT, order='C')
    z_view = z

    for i in range(n):
        for j in range(m):
            z_view[i,j] = zeta[j] + sigma[i, j] * (zeta[j] + h[j])

    return z


