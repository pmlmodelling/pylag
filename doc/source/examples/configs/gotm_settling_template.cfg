[GENERAL]
# Logging
log_level = INFO

# Directory containing input files
in_dir = ./input

# Directory in which simulation output will be saved
out_dir = ./output

# Name of the netCDF data file to be created (without the nc extension)
output_file = %(out_dir)s/pylag

[SIMULATION]
# Simulation type
simulation_type = trace

# Initialisation method
#   : init_file: Initialise particle state data from an ascii file. The
#     name of the file is given by the parameter `initial_positions_file`.
#   : restart_file: Initialise particle state data from a restart file. The
#     name of the restart file is given by the parameter `restart_file_name`
#     in section `RESTART`.
#   : rectangular_grid: Initialise particle state data by creating a set
#     of particles on a regular rectangular grid. (NOT IMPLEMENTED)
initialisation_method = init_file

# Initial positions data file
initial_positions_file = ./input/initial_positions.dat

# Depth coordinates
#   : depth_below_surface: Starting depth is given as the depth below the 
#     (moving) free surface in meters. Positive up, meaning a starting depth
#     of -0.1 is 0.1 m below the free surface. NB A starting depth of 0.1 would
#     be above the free surface and flagged as an error.
#   : hieght_above_bottom: Depth is given as the height above the sea floor
#     in meters. Positive up, meaning a starting depth of 0.1 is 0.1 m above
#     the sea floor.
depth_coordinates = depth_below_surface

# Keep particles at a fixed depth below the surface by restoring to a fixed depth each time step
depth_restoring = False

# The fixed depth below the surface that particles are held at if `depth_restoring' is True. A value
# 0f 0.0 corresponds to the sea surface; a value of -1.0 to 1m below the free surface.
fixed_depth = 0.0

# The time and date at which the first set of particles is released. The format is: yyyy-mm-dd hh:mm:ss
start_datetime = 2010-06-25 12:00:00

# Simulation end time - only used when running a single particle release
end_datetime = 2010-06-26 12:00:00

# Time direction
#  : forward: Forward in time integration
#  : reverse: Backward in time integration
time_direction = forward

# Number of particle releases
number_of_particle_releases = 1

# Number of hours between particle releases
particle_release_interval_in_hours = 0.0

# Simulation duration - used to compute simulation end times with multiple particle releases
duration_in_days = 30.0

# Period at which output data should be saved (s)
output_frequency = 180.0

# Period at which output data is synced to disk (s)
sync_frequency = 180.0

[RESTART]
# The name of the restart file that will be used to initialise the model if
# initialisation_method == restart_file
restart_file_name = ./restart.nc

# Create restart files?
create_restarts = False

# The directory in which restart files will be created. Full or relative path.
restart_dir = ./restart

# Period at which restart files will be created (s)
restart_frequency = 3600.0

[OCEAN_CIRCULATION_MODEL]
# Name of the ocean circulation model or data source from which velocity data
# have been generated. Supported options include:
#   : FVCOM: The Finite Volume Community Ocean Model
#   : GOTM: The General Ocean Turbulence Model
name = GOTM

# Directory containing model output files
data_dir = 

# File containing grid info, in particular the adjacency. If not given, this
# data is extracted from the first data file, which will increase run times. 
# The full path is required.
grid_metrics_file = 

# Data file name stem (e.g. "data_"). Files should be stored at the top level of
# `data_dir'. The model will automatically look for and concatenate across files
# whose names begin with this string (e.g. data_0001.nc, data_0002.nc etc etc). 
# If a grid metrics file is given make sure its file name does not match
# data_file_stem, otherwise the model will attempt to read this too.
data_file_stem = 

# The coordiate system. Options include cartesian (x, y) and geographic (lat, lon)
# coordinate systems. The choice should reflect the grid on which the underlying
# input data (e.g. u, v velocity components) are defined. PyLag will adopt the
# same coordinate system for particle positions. This choice does not impact
# the vertical coordinate system, where at the current time, regulat (z) depth
# levels are assumed. Note that some models such as FVCOM can output particle
# coordinates in both cartesian (x, y) and geographic (lat, lon) coordinates.
# In these cases, and in paricular for small domains where grid distortions
# due to the projection are small, it is generally faster and better to use
# cartesian coordinates.
#     : cartesian - Cartesian (x, y) coordinates.
#     : geographic - Geographic (lat, lon) coordinates.
coordinate_system = cartesian

# Rounding interval (s) used for rounding datetime objects constructed from the
# model time variable, which may have been written to file with only limited
# numerical precision. e.g. a rounding interval of 3600s will round
# times to the nearest hour, and should be used for velocity fields specified
# at hourly intervals.
rounding_interval = 1800

# Constant value for the horizontal eddy diffusivity (units: m^2/s). This value is
# only used with the iterative method `Diff_Const_2D'. See section `NUMERICS'.
horizontal_eddy_diffusivity_constant = 10.0

# Do the output files include the vertical eddy diffusivity?
has_Kz = True

# Do the output files include the horizontal eddy diffusivity?
has_Ah = False

# Do the output files include a flag identifying wet and dry cells?
has_is_wet = True

# Interpolation scheme used when computing the vertical eddy diffusivity. At
# present, this option is only supported by GOTM. If set when working with
# FVCOM model outputs, it will have absolutely no effect on the interpolation
# scheme used. See PyLag's documentation for more details.
# linear - Linear interpolation
# cubic_spline = Cubic spline interpolation
vertical_interpolation_scheme = linear

[NUMERICS]
# The numerical method used to compute changes in particle positions. This option
# controls whether operator splitting is used to combine the contributions of
# advection and diffusion.
# standard          - The iterative method is set through the option `iterative_method'.
#                     The specified iterative method may correspond to cases of pure
#                     advection, pure diffusion or both. In the case of both advection
#                     and diffusion, operator splitting is not performed; rather, the effects
#                     of both processes are computed at the same time using the same time step
#                     and using the specified iterative method. StdNumMethod objects require no
#                     knowledge or the type of iterative method being used; they simply
#                     use it compute the change in a particle's position.
# operator_split_0  - A form of operator splitting in which the advection step is
#                     performed first followed by the diffusion step. The iterative 
#                     methods used for the advection and diffusion steps are set through
#                     the options `adv_iterative_method' and `diff_iterative_method' 
#                     respectively. The two processes can use different time steps; these
#                     are set through the parameters `time_step_adv' and `time_step_diff'
#                     respectively. `time_step_adv' must be greater than or equal to
#                     `time_step_diff' and `time_step_adv'%`time_step_diff' must equal 0.
#                     An exception will be raised if either of these conditions is not
#                     met.
# operator_split_1  - A form of operator splitting in which a half step for diffusion 
#                     is performed first followed by a full advection step followed
#                     by a half diffusion step. The iterative methods used for the advection
#                     and diffusion steps are set through the options `adv_iterative_method'
#                     and `det_iterative_method' respectively. The two processes use different
#                     time steps; these are set through the parameters `time_step_adv' and
#                     `time_step_diff' respectively. `time_step_adv' must be exactly equal to
#                     2 * `time_step_diff'. An exception will be raised if this condition is not
#                     met.
num_method = standard

# The iterative method used to simulate pure advection, pure diffusion or both combined
# (in the absence of operator splitting). For deterministic methods that solve for advection
# only, "Adv" is appended to the beginning of the name. For stochastic methods that solve for
# diffusion only, "Diff" is appended to the beginning of the name. Lastly, for methods that do
# both advection and diffusion, "AdvDiff" is appended to the beginning of the name. The
# dimensionality of each scheme is implicit within the name. 1D schemes compute changes
# in position in e_k only; 2D schemes in e_i and e_j only; and 3D scehemes in e_i, e_j and e_k.
# Adv_RK4_2D - 2D fourth order Runge-Kutta (uses horizontal velocities only)
# Adv_RK4_3D - 3D fourth order Runge-Kutta (uses horizontal and vertical velocities)
# Diff_Const_2D          - 2D method that uses a constant horizontal eddy diffusivity. The constant
#                          is set using the parameter `horizontal_eddy_diffusivity_constant'
#                          in the section OCEAN_CIRCULATION_MODEL.
# Diff_Naive_[1,2]D      - 1- or 2-D Naive scheme; only suitable for homogeneous diffusivity/
#                          diffusivity fields.
# Diff_Euler_1D          - 1D Euler sceheme which includes a pseudo velocity correction term for 
#                          inhomogeneous diffusivity fields. The sceheme converges with
#                          delta t and sqrt(delta t) in the weak and strong sense respectively.
# Diff_Visser_1D         - 1D Visser scheme which includes a pseudo velocity correction for 
#                          inhomgeneous diffusivity fields. Diffusivities are evaluated at a z 
#                          position offset from Z_n. The scheme converges with delta t and 
#                          sqrt(delta t) in the weak and strong sense respectively.
# Diff_Milstein_[1,2,3]D - 1-, 2- or 3-D Milstein schemes that converge with delta t in both the
#                          strong and the weak sense.
# AdvDiff_Milstein_[1,3]D - 3D Milstein scheme that converges with delta t in both the strong and the
#                           weak sense.
iterative_method = AdvDiff_Milstein_1D

# The iterative method used for advection when operator splitting is used:
adv_iterative_method = Adv_RK4_3D

# The iterative method used for diffusion when operator splitting is used:
diff_iterative_method = Diff_Milstein_3D

# The time step used by iterative methods that deal with advection only (s)
time_step_adv = 2

# The time step used by iterative methods that deal with either diffusion only
# or advection and diffusion combined (s).
time_step_diff = 2

[BOUNDARY_CONDITIONS]

# Horizontal boundary condition calculator
# NB These are specific to the coordinate system (cartesian or geographic) in which
# the model are run.
# None - Run without a horizontal boundary condition calculator. This will only
# work successfully if there are no land boundaries, or if the setup is such that
# horizontal boundary crossings are impossible. If neither of these are true,
# and this option is set to `None', an exception will be raised.
# restoring - Restore the particle to its last known good position.
# reflecting - Apply reflecting horizontal boundary conditions
horiz_bound_cond = None

# Vertical boundary condition calculator
# None - Run without a vertical boundary condition calculator. It is okay to set
# this to `None' if it is possible to guarantee a vertical boundadry will not be
# crossed (e.g. if the input data is 2D). An exception will be raised if a vertical
# boundary is crossed and this option is set to `None'.
#   : reflecting - Apply reflecting vertical boundary conditions
#   : bottom_absorbing - Apply reflecting vertical boundary condition at the surface
#                        but an absorbing condition at the bottom.
vert_bound_cond = bottom_absorbing

[SETTLING]

# The type of settling velocity calculator to be used. Names are
# case insensitive.
#
#   : None     - Don't use settling.
#   : Constant - Apply a constant settling rate. See the section
#                CONSTANT_SETTLING_VELOCITY_CALCULATOR for a full
#                list of additional options.
#   : Delayed  - Particles are initially transported along the ocean's
#                surface, but then begin to settle after a fixed period
#                of time. A fixed settling velocity is assigned to particles
#                once they begin to settle. See the section
#                DELAYED_SETTING_VELOCITY_CALCULATOR for a full list of
#                additional options.
settling_velocity_calculator = Constant

[CONSTANT_SETTLING_VELOCITY_CALCULATOR]

# The method used to initialise particle settling velocities. Names
# are case insensitive.
#   : fixed_value    - Use a fixed value for all particles. The value
#                      is set using the option `settling_velocity`. 
#   : uniform_random - Use a uniform random value, meaning each particle
#                      will have a different settling velocity. The limits
#                      for the settling velocity are set using the options
#                      `min_settling_velocity` and `max_settling_velocity`.
initialisation_method = fixed_value

# The settling velocity used for all particles when `initalisation_method`
# is set to `fixed_value` (units: m/s).
settling_velocity = 0.005

# The minimum settling velocity used for all particles when `initalisation_method`
# is set to `uniform_random` (units: m/s).
min_settling_velocity = 0.01

# The maximum settling velocity used for all particles when `initalisation_method`
# is set to `uniform_random` (units: m/s).
max_settling_velocity = 0.1

[DELAYED_SETTLING_VELOCITY_CALCULATOR]

# The duration of the surface transport phase  (units: days).
duration_of_surface_transport_phase_in_days = 6

# The settling velocity used for all particles after they start sinking (units: m/s)
settling_velocity = 0.01

